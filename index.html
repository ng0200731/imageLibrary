<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Image Library — Minimal Shell v2.16.6</title>
  <link rel="stylesheet" href="styles.css?v=2.16.6&bust=20250907074500" />
</head>
<body>
  <div class="app">
    <aside class="sidebar" aria-label="Main menu">
      <div class="brand">
        <div class="hamburger">
          <div class="hamburger__line"></div>
          <div class="hamburger__line"></div>
          <div class="hamburger__line"></div>
        </div>
        <span>Image Library</span>
      </div>
      <nav class="menu">
        <a id="nav-library" class="menu__item is-active" href="#">Image Library</a>
        <a id="nav-upload" class="menu__item" href="#">Upload Image</a>
        <a id="nav-project" class="menu__item" href="#">Project</a>
        <a id="nav-tags" class="menu__item" href="#">Tags</a>
        <a id="nav-settings" class="menu__item" href="#">Settings</a>
      </nav>

      <div class="version-wrapper">
          <span class="version">v2.16.6</span>
      </div>

      <div class="sidebar__footer">
        <button class="button button--primary" type="button">Login</button>
      </div>
    </aside>

    <main class="content">
      <!-- Image Library Page (Default) -->
      <div id="page-library" class="page">
        <header class="content__header">
          <h1 class="title">Image Library</h1>
          <div class="legend" style="margin-top:8px;">Solid = Objective, Dashed = Subjective</div>
          <div id="selection-controls" class="selection-controls is-hidden">
            <button id="select-all-btn" class="button" type="button">Select All</button>
            <button id="deselect-all-btn" class="button" type="button">Deselect All</button>
            <button id="view-pool-btn" class="button" type="button">View Selection Pool</button>
            <button id="back-to-library-btn" class="button is-hidden" type="button">Back to Library</button>
            <button id="add-to-project-btn" class="button button--primary" type="button">Add to Project</button>
            <span id="selection-count" class="selection-count">0 selected</span>
          </div>
        </header>
        <section class="panel">
          <div class="search-bar">
            <div class="search-input-row">
              <input type="text" id="library-search-input" placeholder="Enter tags separated by commas..."
                     autocomplete="off"
                     autocorrect="off"
                     autocapitalize="off"
                     spellcheck="false"
                     data-form-type="other">
              <button id="clear-all-tags" class="button clear-tags-btn" type="button">Clear All</button>
            </div>
            <div id="library-search-chips" class="chips search-chips"></div>
            <div class="search-options">
              <label><input type="radio" name="search-mode" value="AND" checked> AND (all tags must match)</label>
              <label><input type="radio" name="search-mode" value="OR"> OR (any tag can match)</label>
            </div>
          </div>
          <div id="library-grid" class="preview-grid"></div>
        </section>
      </div>

      <!-- Upload Image Page -->
      <div id="page-upload" class="page is-hidden">
          <header class="content__header">
            <h1 class="title">Upload Images</h1>
          </header>
          <section class="panel">
            <div id="dropzone" class="upload-area">
              <div class="preview-header">
                <h2 class="panel__title">Selected Images</h2>
                <div class="upload-actions">
                  <input type="file" id="file-input" class="file-input" multiple />
                  <label for="file-input" class="button">Browse Files</label>
                  <button id="clear-all" class="button" type="button">Clear All</button>
                </div>
              </div>
              <p class="text">Browse, drag & drop, or paste images</p>
              <div id="preview-grid" class="preview-grid"></div>
            </div>
            <div class="upload-actions">
                <button id="upload-button" class="button button--primary" type="button">Upload</button>
            </div>
          </section>

          <!-- Layer 3: Tag panels -->
          <section class="panel">
            <div class="apply-scope">
              Apply to: <button id="apply-all" class="button" type="button">All images</button>
              <button id="apply-selected" class="button" type="button">Selected only</button>
              <span class="legend">Solid = Objective, Dashed = Subjective</span>
            </div>

            <div class="tag-panels">
              <div class="tag-panel tag-panel--objective">
                <div class="tag-panel__header is-objective">
                  OBJECTIVE (FACTS)
                  <button id="auto-fill-btn" class="button auto-fill-btn" type="button">Auto Fill</button>
                </div>
                <div class="tag-panel__body">
                  <!-- Location Fields -->
                  <div class="metadata-section">
                    <h4>Location</h4>
                    <div class="metadata-row">
                      <label class="tag-input">
                        book: <input id="obj-book" type="text" placeholder="book:Album-01" />
                      </label>
                      <label class="tag-input">
                        page: <input id="obj-page" type="text" placeholder="page:15" />
                      </label>
                      <label class="tag-input">
                        row: <input id="obj-row" type="text" placeholder="row:3" />
                      </label>
                      <label class="tag-input">
                        column: <input id="obj-column" type="text" placeholder="column:2" />
                      </label>
                    </div>
                  </div>

                  <!-- Item Details -->
                  <div class="metadata-section">
                    <h4>Item Details</h4>
                    <div class="metadata-row">
                      <label class="tag-input">
                        type: <input id="obj-type" type="text" placeholder="type:stamp" />
                      </label>
                      <label class="tag-input">
                        material: <input id="obj-material" type="text" placeholder="material:paper" />
                      </label>
                      <label class="tag-input">
                        dimension: <input id="obj-dimension" type="text" placeholder="dimension:25x30mm" />
                      </label>
                    </div>
                  </div>

                  <!-- Remark -->
                  <div class="metadata-section">
                    <h4>Remark</h4>
                    <label class="tag-input">
                      remark: <input id="obj-remark" type="text" placeholder="remark:excellent condition, rare find" />
                    </label>
                  </div>

                  <!-- Original Fields -->
                  <div class="metadata-section">
                    <h4>Additional Tags</h4>
                    <label class="tag-input">
                      brand: <input id="obj-brand" type="text" placeholder="brand:nike" />
                    </label>
                    <label class="tag-input">
                      color: <input id="obj-color" type="text" placeholder="color:red" />
                    </label>
                  </div>

                  <div id="obj-chips" class="chips"></div>
                </div>
              </div>

              <div class="tag-panel tag-panel--subjective">
                <div class="tag-panel__header is-subjective">SUBJECTIVE (FEELINGS)</div>
                <div class="tag-panel__body">
                  <div class="subj-inline">
                    <div>
                      <label class="tag-input">Add feelings:
                        <input id="subj-input" type="text" placeholder="type and press Enter/Tab" />
                      </label>
                      <div class="hint">Press Enter or Tab to add; Backspace removes last when empty</div>
                    </div>
                    <div id="subj-chips" class="chips"></div>
                  </div>
                </div>
              </div>
            </div>
          </section>
      </div>

      <!-- Project Page -->
      <div id="page-project" class="page is-hidden">
        <header class="content__header">
          <h1 class="title">Projects</h1>
        </header>
        <section class="panel">
          <!-- Project Search Bar -->
          <div class="project-search-bar">
            <input type="text" id="project-search-input" placeholder="Search project name..." autocomplete="off">
            <button id="project-filter-btn" class="button" type="button">Filter</button>
          </div>
          <div id="project-list" class="project-list">
            <p class="text">No projects created yet. Select images in the Image Library and click "Add to Project" to create your first project.</p>
          </div>
        </section>
      </div>
    </main>
  </div>





  <!-- Lightbox Modal -->
  <div id="lightbox-modal" class="modal is-hidden">
    <span class="modal-close">&times;</span>
    <a class="prev">&#10094;</a>
    <div class="lightbox-content">
      <img class="modal-content" id="lightbox-image">
      <div id="lightbox-tags" class="lightbox-tags"></div>
    </div>
    <a class="next">&#10095;</a>
  </div>

      <!-- Confirmation Dialog -->
      <div id="confirm-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p>Upload Successful! What would you like to do next?</p>
          <div class="modal-buttons">
            <button id="upload-more-btn" class="button">Upload More</button>
            <button id="go-to-library-btn" class="button is-primary">Go to Library</button>
          </div>
        </div>
      </div>



      <!-- Loading Overlay -->
      <div id="loading-overlay" class="modal is-hidden">
        <div class="modal-content-text">
          Uploading... Please wait.
        </div>
      </div>

      <!-- Project Name Input Modal -->
      <div id="project-name-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <h3>Create New Project</h3>
          <p>Enter a name for your project:</p>
          <input type="text" id="project-name-input" placeholder="Project name..." maxlength="50">
          <div class="modal-buttons">
            <button id="cancel-project-btn" class="button">Cancel</button>
            <button id="create-project-btn" class="button is-primary">Create Project</button>
          </div>
        </div>
      </div>

      <!-- Project Created Confirmation Modal -->
      <div id="project-created-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p id="project-success-message">Project created successfully! What would you like to do next?</p>
          <div class="modal-buttons">
            <button id="add-more-projects-btn" class="button">Add More Projects</button>
            <button id="go-to-project-btn" class="button is-primary">Go to Project</button>
          </div>
        </div>
      </div>

      <!-- Image Preview Overlay -->
      <div id="image-preview-overlay" class="image-preview-overlay">
        <div class="image-preview-content">
          <img id="preview-overlay-img" src="" alt="Full Size Preview">
          <button id="preview-overlay-close" class="image-preview-close">✕</button>
        </div>
        <!-- Navigation arrows for Selection Pool -->
        <button id="preview-nav-left" class="image-preview-nav-arrow nav-left hidden">◀</button>
        <button id="preview-nav-right" class="image-preview-nav-arrow nav-right hidden">▶</button>
      </div>

      <!-- Project Detail Overlay Modal -->
      <div id="project-detail-modal" class="project-detail-overlay is-hidden">
        <div class="project-detail-content">
          <!-- Project Header (20%) -->
          <div class="project-detail-header">
            <div class="project-info-section">
              <div class="project-title-row">
                <h2 id="project-detail-name">📁 Project Name</h2>
                <button id="close-project-detail" class="modal-close-btn">✕ Close</button>
              </div>
              <div class="project-stats-row">
                <span id="project-detail-date">📅 Created: 2024-01-15</span>
                <span id="project-detail-count">📊 Total Images: 12</span>
              </div>
              <div class="project-tags-row">
                <span id="project-detail-tags">🏷️ Tags: beach, sunset, family</span>
              </div>
            </div>
          </div>

          <!-- Project Image Grid (80%) -->
          <div class="project-detail-grid-container">
            <div id="project-detail-grid" class="project-detail-grid">
              <!-- Project images will be loaded here -->
            </div>
          </div>
        </div>
      </div>

      <!-- Share Project Modal -->
      <div id="share-project-modal" class="modal-overlay is-hidden">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Share Project</h2>
            <button id="share-project-close" class="modal-close-btn">✕</button>
          </div>
          <div class="modal-body">
            <p>Share "<span id="share-project-name"></span>" via email</p>
            <div class="form-group">
              <label for="share-email-input">Recipient Email Address:</label>
              <input type="email" id="share-email-input" placeholder="Enter email address..." required>
            </div>
            <div class="form-group">
              <label for="share-message-input">Optional Message:</label>
              <textarea id="share-message-input" placeholder="Add a personal message (optional)..." rows="3"></textarea>
            </div>
          </div>
          <div class="modal-footer">
            <button id="cancel-share-btn" class="button">Cancel</button>
            <button id="send-share-btn" class="button button-primary">Send Email</button>
          </div>
        </div>
      </div>

      <!-- Email Sending Overlay -->
      <div id="email-sending-overlay" class="email-overlay is-hidden">
        <div class="email-overlay-content">
          <div class="email-spinner"></div>
          <h3>Sending Email...</h3>
          <p>Please wait while we prepare and send your project email.</p>
          <div class="email-progress">
            <div class="email-progress-bar"></div>
          </div>
        </div>
      </div>

  <script>
    // --- Constants & State ---
    const API_URL = 'http://localhost:3000';
    const navLinks = {
        library: document.getElementById('nav-library'),
        upload: document.getElementById('nav-upload'),
        project: document.getElementById('nav-project'),
    };
    const pages = {
        library: document.getElementById('page-library'),
        upload: document.getElementById('page-upload'),
        project: document.getElementById('page-project'),
    };
    const fileInput = document.getElementById('file-input');
    const previewGrid = document.getElementById('preview-grid');
    const clearAllButton = document.getElementById('clear-all');
    const dropzone = document.getElementById('dropzone');
    const subjInput = document.getElementById('subj-input');
    const subjChips = document.getElementById('subj-chips');

    // Objective metadata inputs
    const objBookInput = document.getElementById('obj-book');
    const objPageInput = document.getElementById('obj-page');
    const objRowInput = document.getElementById('obj-row');
    const objColumnInput = document.getElementById('obj-column');
    const objTypeInput = document.getElementById('obj-type');
    const objMaterialInput = document.getElementById('obj-material');
    const objDimensionInput = document.getElementById('obj-dimension');
    const objRemarkInput = document.getElementById('obj-remark');
    const objBrandInput = document.getElementById('obj-brand');
    const objColorInput = document.getElementById('obj-color');
    const objChips = document.getElementById('obj-chips');
    const autoFillBtn = document.getElementById('auto-fill-btn');
    const modal = document.getElementById('lightbox-modal');
    const modalImg = document.getElementById('lightbox-image');
    const lightboxTags = document.getElementById('lightbox-tags');
    const closeModal = document.querySelector('.modal-close');
    const prevButton = document.querySelector('.prev');
    const nextButton = document.querySelector('.next');
    const uploadButton = document.getElementById('upload-button');
    const librarySearchInput = document.getElementById('library-search-input');
    const libraryGrid = document.getElementById('library-grid');
    const librarySearchChips = document.getElementById('library-search-chips');

    // Header title element for dynamic updates
    const libraryTitle = document.querySelector('#page-library .title');
    const clearAllTagsBtn = document.getElementById('clear-all-tags');
    const searchModeRadios = document.querySelectorAll('input[name="search-mode"]');

    // Selection and project elements
    const selectionControls = document.getElementById('selection-controls');
    const selectAllBtn = document.getElementById('select-all-btn');
    const deselectAllBtn = document.getElementById('deselect-all-btn');
    const viewPoolBtn = document.getElementById('view-pool-btn');
    const backToLibraryBtn = document.getElementById('back-to-library-btn');
    const addToProjectBtn = document.getElementById('add-to-project-btn');
    const selectionCount = document.getElementById('selection-count');
    const projectNameModal = document.getElementById('project-name-modal');
    const projectNameInput = document.getElementById('project-name-input');
    const cancelProjectBtn = document.getElementById('cancel-project-btn');
    const createProjectBtn = document.getElementById('create-project-btn');
    const projectList = document.getElementById('project-list');

    // Project created confirmation modal elements
    const projectCreatedModal = document.getElementById('project-created-modal');
    const projectSuccessMessage = document.getElementById('project-success-message');
    const addMoreProjectsBtn = document.getElementById('add-more-projects-btn');
    const goToProjectBtn = document.getElementById('go-to-project-btn');

    // Project search elements
    const projectSearchInput = document.getElementById('project-search-input');
    const projectFilterBtn = document.getElementById('project-filter-btn');

    // Project detail overlay elements
    const projectDetailModal = document.getElementById('project-detail-modal');
    const closeProjectDetailBtn = document.getElementById('close-project-detail');
    const projectDetailName = document.getElementById('project-detail-name');
    const projectDetailDate = document.getElementById('project-detail-date');
    const projectDetailCount = document.getElementById('project-detail-count');
    const projectDetailTags = document.getElementById('project-detail-tags');
    const projectDetailGrid = document.getElementById('project-detail-grid');

    // Share project modal elements
    const shareProjectModal = document.getElementById('share-project-modal');
    const shareProjectClose = document.getElementById('share-project-close');
    const shareProjectName = document.getElementById('share-project-name');
    const shareEmailInput = document.getElementById('share-email-input');
    const shareMessageInput = document.getElementById('share-message-input');
    const cancelShareBtn = document.getElementById('cancel-share-btn');
    const sendShareBtn = document.getElementById('send-share-btn');
    const emailSendingOverlay = document.getElementById('email-sending-overlay');

    // Image preview overlay elements
    const imagePreviewOverlay = document.getElementById('image-preview-overlay');
    const previewOverlayImg = document.getElementById('preview-overlay-img');
    const previewOverlayClose = document.getElementById('preview-overlay-close');
    const previewNavLeft = document.getElementById('preview-nav-left');
    const previewNavRight = document.getElementById('preview-nav-right');

    let filesToUpload = [];
    let currentImageIndex = 0;
    let imageSources = [];
    let libraryImages = []; // Store current library images for lightbox navigation
    let searchTags = []; // Store current search tags as chips
    let selectedImages = []; // Store selected image IDs for project creation
    let tagSelectedImages = []; // Store images selected by tags (always show tag icon)
    let imageSelectionOrder = {}; // Track selection timestamps for ordering
    let projects = []; // Store created projects
    let isPoolView = false; // Track if we're viewing selection pool
    let lastCreatedProject = null; // Store the last created project for navigation

    // Selection Pool preview navigation
    let currentPreviewImages = []; // Array of images for navigation
    let currentPreviewIndex = 0; // Current image index in preview
    let isSelectionPoolPreview = false; // Track if we're in Selection Pool preview mode

    // --- Function Definitions ---

    function updateLibraryTitle(isPoolView = false) {
        if (isPoolView) {
            libraryTitle.textContent = 'Image Library (Selection Pool)';
        } else {
            libraryTitle.textContent = 'Image Library';
        }
    }

    function updateSearchInputVisibility() {
        const searchInput = document.getElementById('library-search-input');
        const clearAllBtn = document.getElementById('clear-all-tags');
        const searchModeRadios = document.querySelectorAll('input[name="search-mode"]');
        const libraryTitle = document.querySelector('#page-library .title');

        // Check if we're in Selection Pool view by multiple criteria
        const isSelectionPool = libraryTitle && libraryTitle.textContent.includes('Selection Pool');
        const hasTagSearch = searchTags.length > 0;
        const hasSelectedImages = selectedImages.length > 0;

        console.log('updateSearchInputVisibility - isPoolView:', isPoolView, 'isSelectionPool:', isSelectionPool, 'hasTagSearch:', hasTagSearch, 'hasSelectedImages:', hasSelectedImages);

        if (isPoolView || isSelectionPool || (hasTagSearch && hasSelectedImages)) {
            // DISABLE search input and related controls in Selection Pool view
            searchInput.disabled = true;
            clearAllBtn.disabled = true;
            searchModeRadios.forEach(radio => radio.disabled = true);

            // Add visual styling for disabled state
            searchInput.style.opacity = '0.5';
            searchInput.style.cursor = 'not-allowed';
            clearAllBtn.style.opacity = '0.5';
            clearAllBtn.style.cursor = 'not-allowed';

            console.log('Search controls DISABLED for Selection Pool view');
        } else {
            // ENABLE search input and related controls in regular Library view
            searchInput.disabled = false;
            clearAllBtn.disabled = false;
            searchModeRadios.forEach(radio => radio.disabled = false);

            // Remove visual styling for disabled state
            searchInput.style.opacity = '1';
            searchInput.style.cursor = 'text';
            clearAllBtn.style.opacity = '1';
            clearAllBtn.style.cursor = 'pointer';

            console.log('Search controls ENABLED for regular Library view');
        }
    }

    async function displayLibraryImages() {
        console.log('displayLibraryImages called, selectedImages at start:', selectedImages);
        console.log('isPoolView:', isPoolView);

        const searchMode = document.querySelector('input[name="search-mode"]:checked').value;
        const currentSearchTags = searchTags.map(tag => tag.text);

        try {
            // Get all images first
            const allImagesResponse = await fetch(`${API_URL}/images`);
            const allImages = await allImagesResponse.json();

            let imagesToDisplay = [];

            if (isPoolView) {
                // Pool view - show only selected images, sorted by selection order (latest first)
                imagesToDisplay = allImages.filter(img => selectedImages.includes(img.id));

                // Sort by selection timestamp - latest selections first
                imagesToDisplay.sort((a, b) => {
                    const timestampA = imageSelectionOrder[a.id] || 0;
                    const timestampB = imageSelectionOrder[b.id] || 0;
                    return timestampB - timestampA; // Descending order (latest first)
                });

                console.log('Pool view - sorted by selection order, latest first');
            } else if (currentSearchTags.length === 0) {
                // Library view with no search tags - show all images, latest first
                // DON'T clear tagSelectedImages here - preserve historical tag selections
                imagesToDisplay = allImages;

                // Sort by image ID in descending order (latest uploads first)
                imagesToDisplay.sort((a, b) => b.id - a.id);

                console.log('Library view with no active tags, sorted latest first, preserving tagSelectedImages:', tagSelectedImages);
            } else {
                // Library view with search tags - show tag-matching + manually selected images
                console.log('Fetching tag-matching images for tags:', currentSearchTags);
                const tagResponse = await fetch(`${API_URL}/images?tags=${currentSearchTags.join(',')}&mode=${searchMode}`);

                if (!tagResponse.ok) {
                    throw new Error(`Tag search failed: ${tagResponse.status} ${tagResponse.statusText}`);
                }

                const tagMatchingImages = await tagResponse.json();
                console.log('Tag-matching images found:', tagMatchingImages.length);

                // Get manually selected images that might not match tags
                const manuallySelectedImages = allImages.filter(img => selectedImages.includes(img.id));
                console.log('Manually selected images:', manuallySelectedImages.length);

                // Combine tag-matching and manually selected images (remove duplicates)
                const combinedImageIds = new Set();
                imagesToDisplay = [];

                // Update tag-selected images (add new ones, keep existing ones)
                const newTagSelectedImages = tagMatchingImages.map(img => img.id);
                const currentTimestamp = Date.now();

                // Track selection timestamps for new tag-selected images
                newTagSelectedImages.forEach(imageId => {
                    if (!tagSelectedImages.includes(imageId)) {
                        // New tag selection - record timestamp
                        imageSelectionOrder[imageId] = currentTimestamp;
                    }
                });

                tagSelectedImages = [...new Set([...tagSelectedImages, ...newTagSelectedImages])];

                // Add tag-matching images
                tagMatchingImages.forEach(img => {
                    if (!combinedImageIds.has(img.id)) {
                        combinedImageIds.add(img.id);
                        imagesToDisplay.push(img);
                    }
                });

                // Add manually selected images that weren't already included
                manuallySelectedImages.forEach(img => {
                    if (!combinedImageIds.has(img.id)) {
                        combinedImageIds.add(img.id);
                        imagesToDisplay.push(img);
                    }
                });

                // Sort combined results by image ID in descending order (latest first)
                imagesToDisplay.sort((a, b) => b.id - a.id);

                console.log('Combined images to display:', imagesToDisplay.length, '(sorted latest first)');
                console.log('Tag-selected images:', tagSelectedImages);
            }

            // Update header based on view type
            if (isPoolView) {
                updateLibraryTitle(true); // Selection Pool
            } else if (currentSearchTags.length > 0) {
                updateLibraryTitle(true); // Filtered view (also Selection Pool)
            } else {
                updateLibraryTitle(false); // Full library
            }

            // Update search input visibility based on view type
            updateSearchInputVisibility();

            // SAFETY CHECK: Always disable search controls if title shows Selection Pool
            setTimeout(() => {
                const libraryTitle = document.querySelector('#page-library .title');
                if (libraryTitle && libraryTitle.textContent.includes('Selection Pool')) {
                    const searchInput = document.getElementById('library-search-input');
                    const clearAllBtn = document.getElementById('clear-all-tags');
                    const searchModeRadios = document.querySelectorAll('input[name="search-mode"]');

                    searchInput.disabled = true;
                    clearAllBtn.disabled = true;
                    searchModeRadios.forEach(radio => radio.disabled = true);

                    searchInput.style.opacity = '0.5';
                    searchInput.style.cursor = 'not-allowed';
                    clearAllBtn.style.opacity = '0.5';
                    clearAllBtn.style.cursor = 'not-allowed';

                    console.log('SAFETY CHECK: Search controls disabled for Selection Pool');
                }
            }, 100);

            const images = imagesToDisplay;

            libraryGrid.innerHTML = '';
            libraryImages = []; // Reset library images array
            // Keep existing selected images - don't reset selectedImages array

            // Check which tags have matches and update chip colors
            await updateTagChipColors(currentSearchTags, searchMode);

            images.forEach((image, index) => {
                const card = document.createElement('div');
                card.className = 'preview-card library-card';
                card.dataset.imageId = image.id;

                const img = document.createElement('img');
                const imageSrc = `${API_URL}/${image.filepath.replace(/\\/g, '/')}`;
                img.src = imageSrc;

                // Store image data for lightbox navigation
                libraryImages.push({
                    src: imageSrc,
                    index: index,
                    tags: image.tags || [],
                    id: image.id
                });

                // Add click event listener based on view mode
                img.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Image clicked:', image.id, 'isPoolView:', isPoolView, 'index:', index);

                    // In both library and pool view, allow selection toggling
                    toggleImageSelection(image.id, card);
                });

                // Add double-click handler for lightbox in pool view
                if (isPoolView) {
                    img.addEventListener('dblclick', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Image double-clicked, opening lightbox for index:', index);
                        openLibraryLightbox(index);
                    });
                }

                // Add cursor pointer style - always clickable in pool view
                img.style.cursor = 'pointer';

                // Ensure card is also clickable in pool view
                if (isPoolView) {
                    card.style.cursor = 'pointer';
                }

                card.appendChild(img);

                // Add eye icon for image preview (both library view and pool view)
                const eyeIcon = document.createElement('div');
                eyeIcon.className = 'image-preview-eye';
                eyeIcon.textContent = '🔍';
                eyeIcon.title = 'Preview full size image';

                eyeIcon.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    // Check if we're in Selection Pool view (by title or isPoolView flag)
                    const libraryTitle = document.querySelector('#page-library .title');
                    const isSelectionPoolView = isPoolView || (libraryTitle && libraryTitle.textContent.includes('Selection Pool'));

                    console.log('Lens clicked - isPoolView:', isPoolView, 'isSelectionPoolView:', isSelectionPoolView);

                    if (isSelectionPoolView) {
                        // Selection Pool preview with navigation
                        console.log('Opening Selection Pool preview for image:', image.id, 'at index:', index);
                        showSelectionPoolPreview(image, imagesToDisplay, index);
                    } else {
                        // Regular library preview
                        console.log('Opening regular library preview for image:', image.id);
                        showImagePreviewOverlay(imageSrc, image);
                    }
                });

                card.appendChild(eyeIcon);

                // Add tag overlay - show tags on ALL images
                const matchingTags = getMatchingTags(image.tags || [], currentSearchTags);
                const isTagSelected = tagSelectedImages.includes(image.id);
                const imageTags = image.tags || [];

                if (imageTags.length > 0) {
                    const tagOverlay = document.createElement('div');
                    tagOverlay.className = 'tag-overlay';

                    if (matchingTags.length > 0) {
                        // Highlight matching tags for current search
                        tagOverlay.classList.add('has-matches');
                        tagOverlay.textContent = matchingTags.join(', ');
                    } else {
                        // Show first 3 tags for all other images
                        tagOverlay.textContent = imageTags.slice(0, 3).join(', ');
                        if (imageTags.length > 3) {
                            tagOverlay.textContent += ` +${imageTags.length - 3}`;
                        }
                    }

                    card.appendChild(tagOverlay);
                }

                // Handle selection state
                const wasAlreadySelected = selectedImages.includes(image.id);
                const hasMatchingTags = currentSearchTags.length > 0 && matchingTags.length > 0;
                // isTagSelected already calculated above



                if (isPoolView) {
                    // In pool view, all displayed images are selected and locked
                    card.classList.add('selected', 'pool-view');

                    // Add visual indicator for selection type - prioritize tag selection
                    if (isTagSelected) {
                        card.classList.add('tag-selection');
                    } else if (wasAlreadySelected) {
                        card.classList.add('manual-selection');
                    }
                } else {
                    // In library view, handle normal selection logic
                    if (wasAlreadySelected || hasMatchingTags) {
                        card.classList.add('selected');

                        // Add visual indicator for selection type - prioritize tag selection
                        // Key fix: Check isTagSelected FIRST, regardless of current search tags
                        if (isTagSelected) {
                            card.classList.add('tag-selection');
                        } else if (hasMatchingTags) {
                            card.classList.add('tag-selection');
                        } else if (wasAlreadySelected) {
                            card.classList.add('manual-selection');
                        }

                        // Only add to selectedImages if not already there
                        if (!wasAlreadySelected) {
                            selectedImages.push(image.id);
                        }
                    }
                }

                libraryGrid.appendChild(card);
            });

            // Show selection controls if there are images and search is active OR if we have selections
            if (images.length > 0 && (currentSearchTags.length > 0 || selectedImages.length > 0)) {
                selectionControls.classList.remove('is-hidden');
                updateSelectionState(); // This will call updateButtonVisibility()
            } else {
                selectionControls.classList.add('is-hidden');
                // Only clear selectedImages if we're not in pool view and have no search tags
                if (!isPoolView && currentSearchTags.length === 0) {
                    selectedImages = [];
                }
                updateButtonVisibility(); // Ensure buttons are correct even when no selections
            }

            console.log('displayLibraryImages completed, selectedImages at end:', selectedImages);
        } catch (error) {
            console.error('Error fetching images:', error);
            console.error('Error details:', {
                message: error.message,
                stack: error.stack,
                isPoolView: isPoolView,
                selectedImages: selectedImages,
                searchTags: searchTags
            });
            libraryGrid.innerHTML = '<p>Error loading images. Please try again.</p>';

            // Reset states to prevent getting stuck
            if (isPoolView) {
                console.log('Resetting pool view state due to error');
                isPoolView = false;
                viewPoolBtn.classList.remove('is-hidden');
                backToLibraryBtn.classList.add('is-hidden');
                selectAllBtn.classList.remove('is-hidden');
                deselectAllBtn.classList.remove('is-hidden');
            }
        }
    }

    async function updateTagChipColors(tags, searchMode) {
        for (const tagText of tags) {
            try {
                const response = await fetch(`${API_URL}/images?tags=${tagText}&mode=OR`);
                const images = await response.json();
                const hasMatches = images.length > 0;

                // Update the chip color based on matches
                const chip = Array.from(librarySearchChips.querySelectorAll('.search-chip')).find(
                    chip => chip.textContent.replace(/[×x]$/, '').trim() === tagText
                );

                if (chip) {
                    if (hasMatches) {
                        chip.classList.remove('no-matches');
                        chip.classList.add('has-matches');
                    } else {
                        chip.classList.remove('has-matches');
                        chip.classList.add('no-matches');
                    }
                }

                // Update searchTags array
                const tagIndex = searchTags.findIndex(tag => tag.text === tagText);
                if (tagIndex !== -1) {
                    searchTags[tagIndex].hasMatches = hasMatches;
                }
            } catch (error) {
                console.error(`Error checking matches for tag "${tagText}":`, error);
            }
        }
    }

    function navigateTo(pageName) {
        const confirmModal = document.getElementById('confirm-modal');
        // Do not navigate if the confirmation modal is visible
        if (confirmModal && !confirmModal.classList.contains('is-hidden')) {
            return;
        }
        Object.values(pages).forEach(page => page.classList.add('is-hidden'));
        document.querySelectorAll('.menu__item').forEach(link => link.classList.remove('is-active'));
        pages[pageName].classList.remove('is-hidden');
        navLinks[pageName].classList.add('is-active');

        if (pageName === 'library') {
            initializeFreshSearchInput();
            displayLibraryImages();
        } else if (pageName === 'project') {
            displayProjects();
        }
    }

    function handleFiles(files) {
        for (const file of files) {
            if (!file.type.startsWith('image/')) continue;
            filesToUpload.push(file);

            const reader = new FileReader();
            reader.onload = (e) => {
                const card = document.createElement('div');
                card.className = 'preview-card';

                const img = document.createElement('img');
                img.src = e.target.result;
                img.addEventListener('click', (event) => {
                    const allImages = Array.from(previewGrid.querySelectorAll('img'));
                    const clickedIndex = allImages.indexOf(event.target);
                    openModal(clickedIndex);
                });

                const del = document.createElement('button');
                del.type = 'button';
                del.className = 'delete-btn';
                del.textContent = '×';
                del.addEventListener('click', () => {
                    const indexToRemove = filesToUpload.indexOf(file);
                    if (indexToRemove > -1) {
                        filesToUpload.splice(indexToRemove, 1);
                    }
                    card.remove();
                });

                card.appendChild(del);
                card.appendChild(img);
                previewGrid.appendChild(card);
            };
            reader.readAsDataURL(file);
        }
    }

    function addSubjChip(label) {
        const text = (label || '').toLowerCase().trim();
        if (!text) return;
        if ([...subjChips.querySelectorAll('.chip')].some(c => c.textContent.replace(/[×x]$/, '').trim() === text)) return;
        const chip = document.createElement('span');
        chip.className = 'chip is-subjective';
        chip.textContent = text;
        chip.tabIndex = 0;
        chip.addEventListener('click', () => chip.classList.toggle('is-selected'));
        const x = document.createElement('button');
        x.type = 'button';
        x.className = 'x';
        x.textContent = '×';
        x.addEventListener('click', (ev) => { ev.stopPropagation(); chip.remove(); });
        chip.appendChild(x);
        subjChips.appendChild(chip);
    }

    function handleSubjCommit() {
        const parts = subjInput.value.split(',');
        parts.forEach(p => addSubjChip(p));
        subjInput.value = '';
    }

    function handleObjCommit(input) {
        const value = input.value.trim();
        if (value) {
            // Create tag from input value (already includes prefix like "book:", "type:", etc.)
            addObjChip(value);
            input.value = '';
        }
    }

    function addObjChip(text) {
        if (!text.trim()) return;

        const chip = document.createElement('div');
        chip.className = 'chip chip--objective';
        chip.textContent = text.trim();

        const x = document.createElement('span');
        x.className = 'chip-remove';
        x.textContent = '×';
        x.addEventListener('click', (ev) => { ev.stopPropagation(); chip.remove(); });
        chip.appendChild(x);
        objChips.appendChild(chip);
    }

    function autoFillMetadata() {
        // Sample data arrays for random selection
        const sampleData = {
            books: ['Album-01', 'Collection-A', 'Stamps-2024', 'Vintage-Set', 'Modern-Series'],
            pages: ['12', '25', '8', '33', '15', '7', '41'],
            rows: ['1', '2', '3', '4', '5'],
            columns: ['1', '2', '3', '4'],
            types: ['stamp', 'coin', 'banknote', 'postcard', 'photo', 'document'],
            materials: ['paper', 'metal', 'plastic', 'fabric', 'wood', 'ceramic'],
            dimensions: ['25x30mm', '15x20mm', '40x25mm', '30x35mm', '20x25mm', '50x30mm'],
            remarks: [
                'excellent condition, rare find',
                'mint condition, first edition',
                'good condition, slight wear',
                'vintage piece, collector item',
                'pristine condition, never used',
                'historical significance, well preserved'
            ],
            brands: ['royal-mail', 'usps', 'canada-post', 'deutsche-post', 'japan-post'],
            colors: ['red', 'blue', 'green', 'yellow', 'purple', 'orange', 'black', 'white']
        };

        // Random selection function
        const random = (arr) => arr[Math.floor(Math.random() * arr.length)];

        // Fill all fields with random sample data
        if (objBookInput) objBookInput.value = `book:${random(sampleData.books)}`;
        if (objPageInput) objPageInput.value = `page:${random(sampleData.pages)}`;
        if (objRowInput) objRowInput.value = `row:${random(sampleData.rows)}`;
        if (objColumnInput) objColumnInput.value = `column:${random(sampleData.columns)}`;
        if (objTypeInput) objTypeInput.value = `type:${random(sampleData.types)}`;
        if (objMaterialInput) objMaterialInput.value = `material:${random(sampleData.materials)}`;
        if (objDimensionInput) objDimensionInput.value = `dimension:${random(sampleData.dimensions)}`;
        if (objRemarkInput) objRemarkInput.value = `remark:${random(sampleData.remarks)}`;
        if (objBrandInput) objBrandInput.value = `brand:${random(sampleData.brands)}`;
        if (objColorInput) objColorInput.value = `color:${random(sampleData.colors)}`;

        // Visual feedback
        autoFillBtn.textContent = 'Filled!';
        autoFillBtn.style.background = '#4caf50';
        setTimeout(() => {
            autoFillBtn.textContent = 'Auto Fill';
            autoFillBtn.style.background = '#2196f3';
        }, 1500);
    }

    function updateArrowVisibility() {
        const totalImages = imageSources.length;
        prevButton.style.display = (currentImageIndex > 0 && totalImages > 1) ? 'block' : 'none';
        nextButton.style.display = (currentImageIndex < totalImages - 1 && totalImages > 1) ? 'block' : 'none';
    }

    function openModal(index) {
        currentImageIndex = index;
        imageSources = Array.from(previewGrid.querySelectorAll('img')).map(img => img.src);
        modalImg.src = imageSources[currentImageIndex];
        modal.classList.remove('is-hidden');
        updateArrowVisibility();
    }

    function showImage(index) {
        if (index >= imageSources.length || index < 0) return;
        currentImageIndex = index;
        modalImg.src = imageSources[currentImageIndex];
        updateArrowVisibility();
    }

    function hideModal() {
        modal.classList.add('is-hidden');
    }

    // --- Library Lightbox Functions ---

    function openLibraryLightbox(index) {
        currentImageIndex = index;
        imageSources = libraryImages.map(img => img.src);
        modalImg.src = imageSources[currentImageIndex];
        displayLightboxTags(index);
        modal.classList.remove('is-hidden');
        updateArrowVisibility();
    }

    function showLibraryImage(index) {
        if (index >= imageSources.length || index < 0) return;
        currentImageIndex = index;
        modalImg.src = imageSources[currentImageIndex];
        displayLightboxTags(index);
        updateArrowVisibility();
    }

    // --- Search Tag Chip Functions ---

    function addSearchTagChip(tagText, hasMatches = true) {
        const text = tagText.toLowerCase().trim();
        if (!text) return;

        // Check if tag already exists
        if (searchTags.some(tag => tag.text === text)) return;

        // Add to searchTags array
        searchTags.push({ text: text, hasMatches: hasMatches });

        // Create chip element
        const chip = document.createElement('span');
        chip.className = hasMatches ? 'chip search-chip' : 'chip search-chip no-matches';
        chip.textContent = text;
        chip.tabIndex = 0;

        // Add delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.className = 'chip-delete';
        deleteBtn.textContent = '×';
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removeSearchTagChip(text);
        });

        chip.appendChild(deleteBtn);
        librarySearchChips.appendChild(chip);
        updateClearButtonState();
    }

    function removeSearchTagChip(tagText) {
        // Remove from searchTags array
        searchTags = searchTags.filter(tag => tag.text !== tagText);

        // Remove from DOM
        const chips = librarySearchChips.querySelectorAll('.search-chip');
        chips.forEach(chip => {
            if (chip.textContent.replace(/[×x]$/, '').trim() === tagText) {
                chip.remove();
            }
        });

        // Update search input and refresh results
        updateSearchInput();
        updateClearButtonState();
        displayLibraryImages();
    }



    function clearAllSearchChips() {
        console.log('clearAllSearchChips called - clearing everything and returning to main library');
        console.log('Before clear - searchTags:', searchTags.length, 'selectedImages:', selectedImages.length, 'tagSelectedImages:', tagSelectedImages.length, 'isPoolView:', isPoolView);

        // Clear all search tags
        searchTags = [];
        tagSelectedImages = []; // Clear tag-selected images
        librarySearchChips.innerHTML = '';


        // Clear all selected images
        selectedImages = [];

        // Clear all selection timestamps
        imageSelectionOrder = {};

        // Remove visual selection styling from all cards
        const cards = document.querySelectorAll('.library-card');
        cards.forEach(card => {
            card.classList.remove('selected');
            card.classList.remove('manual-selection');
            card.classList.remove('tag-selection');
        });

        // Ensure we're in main library view (not pool view)
        isPoolView = false;

        // Update UI states
        updateClearButtonState();
        updateSelectionState();

        // Refresh to show full library with no selections or filters
        displayLibraryImages();

        console.log('After clear - returned to main library with no selections or filters');
        console.log('Final state - searchTags:', searchTags.length, 'selectedImages:', selectedImages.length, 'isPoolView:', isPoolView);
    }



    function updateSearchInput() {
        librarySearchInput.value = searchTags.map(tag => tag.text).join(', ');
    }

    function updateClearButtonState() {
        // Enable "Clear All" button if there are search tags OR selected images
        clearAllTagsBtn.disabled = searchTags.length === 0 && selectedImages.length === 0;
    }

    function initializeFreshSearchInput() {
        // Clear any cached or remembered values
        librarySearchInput.value = '';
        librarySearchInput.defaultValue = '';

        // Clear any browser autocomplete cache for this session
        if (librarySearchInput.form) {
            librarySearchInput.form.reset();
        }

        // Force clear any browser-stored values
        setTimeout(() => {
            librarySearchInput.value = '';
        }, 0);

        // Clear search chips and reset state
        clearAllSearchChips();
    }

    function getMatchingTags(imageTags, searchTags) {
        if (!imageTags || !searchTags || searchTags.length === 0) {
            return [];
        }

        // Return tags that are both in the image and in the search
        return imageTags.filter(imageTag =>
            searchTags.some(searchTag =>
                searchTag.toLowerCase() === imageTag.toLowerCase()
            )
        );
    }

    function displayLightboxTags(index) {
        if (index >= libraryImages.length || index < 0) {
            lightboxTags.innerHTML = '';
            return;
        }

        const currentImage = libraryImages[index];
        const imageTags = currentImage.tags || [];

        lightboxTags.innerHTML = '';

        if (imageTags.length === 0) {
            lightboxTags.innerHTML = '<span class="no-tags">No tags</span>';
            return;
        }

        // Create tag chips for lightbox
        imageTags.forEach(tagText => {
            const chip = document.createElement('span');
            chip.className = 'lightbox-tag-chip';
            chip.textContent = tagText;

            // Highlight if it matches current search
            const currentSearchTags = searchTags.map(tag => tag.text);
            if (currentSearchTags.some(searchTag =>
                searchTag.toLowerCase() === tagText.toLowerCase())) {
                chip.classList.add('highlighted');
            }

            lightboxTags.appendChild(chip);
        });
    }

    // --- Selection and Project Management Functions ---

    function toggleImageSelection(imageId, cardElement) {
        // Allow selection/deselection in both library and pool view

        const isSelected = selectedImages.includes(imageId);
        const isTagSelected = tagSelectedImages.includes(imageId);

        if (isSelected) {
            // Deselect - allow full deselection for both manual and tag-selected images
            selectedImages = selectedImages.filter(id => id !== imageId);
            cardElement.classList.remove('selected', 'manual-selection', 'tag-selection');

            // Remove from selection order tracking
            delete imageSelectionOrder[imageId];

            // Don't automatically re-select tag images - allow them to be fully deselected
        } else {
            // Select
            selectedImages.push(imageId);
            cardElement.classList.add('selected');

            // Track selection timestamp for ordering (latest first in pool view)
            imageSelectionOrder[imageId] = Date.now();

            // Update CSS class based on selection type
            cardElement.classList.remove('manual-selection', 'tag-selection');
            if (isTagSelected) {
                cardElement.classList.add('tag-selection');
            } else {
                cardElement.classList.add('manual-selection');
            }
        }

        updateSelectionState();
    }

    function updateSelectionState() {
        selectionCount.textContent = `${selectedImages.length} selected`;
        addToProjectBtn.disabled = selectedImages.length === 0;
        updateButtonVisibility();
        updateClearButtonState(); // Update Clear All button state when selections change
    }

    function isShowingSelectionPool() {
        // We're showing selection pool if:
        // 1. We have active search tags AND selections, OR
        // 2. We're in pool view
        const hasActiveTags = searchTags.length > 0;
        const hasSelections = selectedImages.length > 0;
        return isPoolView || (hasActiveTags && hasSelections);
    }



    function updateButtonVisibility() {
        console.log('updateButtonVisibility called, isPoolView:', isPoolView, 'selectedImages.length:', selectedImages.length);
        console.log('searchTags.length:', searchTags.length);

        const hasSelections = selectedImages.length > 0;
        const showingSelectionPool = isShowingSelectionPool();

        if (isPoolView) {
            // Pool view: Show all 4 buttons (Select All, Deselect All, Back to Library, Add to Project)
            viewPoolBtn.classList.add('is-hidden');
            viewPoolBtn.disabled = true;

            backToLibraryBtn.classList.remove('is-hidden');
            backToLibraryBtn.disabled = false;

            // Keep Select All and Deselect All visible in pool view
            selectAllBtn.classList.remove('is-hidden');
            selectAllBtn.disabled = false;

            deselectAllBtn.classList.remove('is-hidden');
            deselectAllBtn.disabled = !hasSelections; // Dimmed when no selections

            addToProjectBtn.disabled = !hasSelections; // Dimmed when no selections

            console.log('Set buttons for pool view - showing all 4 buttons');
        } else {
            // Library view: Show library controls, hide back button
            viewPoolBtn.classList.remove('is-hidden');

            // Change button text and behavior based on context
            if (searchTags.length > 0 && !isPoolView) {
                // Library view with active tags - show "Back to Library"
                viewPoolBtn.textContent = 'Back to Library';
                viewPoolBtn.disabled = false;
            } else {
                // Normal library view - show "View Selection Pool"
                viewPoolBtn.textContent = 'View Selection Pool';
                viewPoolBtn.disabled = !hasSelections; // Dimmed when no selections
            }

            backToLibraryBtn.classList.add('is-hidden');
            backToLibraryBtn.disabled = true;

            selectAllBtn.classList.remove('is-hidden');
            selectAllBtn.disabled = false; // Always enabled in library view

            deselectAllBtn.classList.remove('is-hidden');
            deselectAllBtn.disabled = !hasSelections; // Dimmed when no selections

            addToProjectBtn.disabled = !hasSelections; // Dimmed when no selections

            console.log('Set buttons for library view, showingSelectionPool:', showingSelectionPool);
        }

        // Log final button states for debugging
        console.log('Final button states:');
        console.log('viewPoolBtn - hidden:', viewPoolBtn.classList.contains('is-hidden'), 'disabled:', viewPoolBtn.disabled);
        console.log('backToLibraryBtn - hidden:', backToLibraryBtn.classList.contains('is-hidden'), 'disabled:', backToLibraryBtn.disabled);
        console.log('selectAllBtn - hidden:', selectAllBtn.classList.contains('is-hidden'), 'disabled:', selectAllBtn.disabled);
        console.log('deselectAllBtn - hidden:', deselectAllBtn.classList.contains('is-hidden'), 'disabled:', deselectAllBtn.disabled);
        console.log('addToProjectBtn - disabled:', addToProjectBtn.disabled);
    }

    function selectAllImages() {
        const cards = document.querySelectorAll('.library-card');
        selectedImages = [];
        const currentTimestamp = Date.now();

        cards.forEach(card => {
            const imageId = parseInt(card.dataset.imageId);
            selectedImages.push(imageId);

            // Track selection timestamp for ordering
            imageSelectionOrder[imageId] = currentTimestamp;

            // Add selected class
            card.classList.add('selected');

            // Remove pool-deselected class to restore red borders
            card.classList.remove('pool-deselected');

            // Determine and apply the correct selection type class
            const isTagSelected = tagSelectedImages.includes(imageId);
            card.classList.remove('manual-selection', 'tag-selection');

            if (isTagSelected) {
                card.classList.add('tag-selection');
            } else {
                card.classList.add('manual-selection');
            }
        });

        updateSelectionState();
    }

    function deselectAllImages() {
        // Safety check: Don't execute if no selections
        if (selectedImages.length === 0) {
            console.warn('deselectAllImages called but no images are selected');
            return;
        }

        const cards = document.querySelectorAll('.library-card');

        // Clear selection timestamps for all deselected images
        selectedImages.forEach(imageId => {
            delete imageSelectionOrder[imageId];
        });

        selectedImages = [];

        cards.forEach(card => {
            if (isPoolView) {
                // In Selection Pool, remove red borders but keep icons
                card.classList.remove('selected');
                card.classList.add('pool-deselected');
            } else {
                // In Library view, remove all selection-related classes completely
                card.classList.remove('selected');
                card.classList.remove('manual-selection');
                card.classList.remove('tag-selection');
                card.classList.remove('pool-deselected');
            }
        });

        updateSelectionState();
    }



    function handleViewPoolClick() {
        if (viewPoolBtn.textContent === 'Back to Library') {
            // Show full library but preserve tag selection history
            showFullLibrary();
        } else {
            // View selection pool
            viewSelectionPool();
        }
    }

    async function viewSelectionPool() {
        console.log('=== viewSelectionPool START ===');
        console.log('selectedImages:', selectedImages);
        console.log('selectedImages.length:', selectedImages.length);

        if (selectedImages.length === 0) {
            alert('No images selected. Please select some images first.');
            return;
        }

        console.log('Setting isPoolView to true');
        isPoolView = true;

        // Update header to show Selection Pool
        updateLibraryTitle(true);

        // Use the main display function which now handles pool view
        await displayLibraryImages();
        console.log('=== viewSelectionPool END ===');
    }

    function showFullLibrary() {
        console.log('=== showFullLibrary START ===');
        console.log('Showing full library while preserving green tag chips for user reference');

        // Clear search tags to show ALL images (provides visual feedback)
        searchTags = [];

        // DON'T clear tagSelectedImages - preserve tag selection status for overlays
        // DON'T clear chips and input - keep them visible for user reference

        // Ensure we're in library view
        isPoolView = false;

        // Update header back to normal library view
        updateLibraryTitle(false);

        // Refresh to show full library (all images)
        displayLibraryImages();

        console.log('=== showFullLibrary END ===');
    }

    function backToFullLibrary() {
        console.log('=== backToFullLibrary START ===');
        console.log('Returning to full library while preserving green tag chips for user reference');
        console.log('backToFullLibrary called - preserving tagSelectedImages:', tagSelectedImages);

        // Clear search tags to show ALL images (provides visual feedback)
        searchTags = [];

        // DON'T clear tagSelectedImages - preserve tag selection history for overlays
        // DON'T clear chips and input - keep them visible for user reference

        // Ensure we're in library view
        isPoolView = false;

        // Update header back to normal library view
        updateLibraryTitle(false);

        // Refresh to show full library (all images)
        displayLibraryImages();

        console.log('=== backToFullLibrary END ===');
    }

    function backToLibrary() {
        try {
            console.log('=== backToLibrary START ===');
            console.log('selectedImages before:', selectedImages);
            console.log('searchTags before:', searchTags);
            console.log('tagSelectedImages before:', tagSelectedImages);
            console.log('isPoolView before:', isPoolView);

            // Safety check: Don't execute if button should be disabled
            if (backToLibraryBtn.disabled) {
                console.error('backToLibrary called but button is disabled! This should not happen.');
                console.log('Button state - hidden:', backToLibraryBtn.classList.contains('is-hidden'), 'disabled:', backToLibraryBtn.disabled);
                return;
            }

            // Check if we're actually in pool view
            if (!isPoolView) {
                console.warn('backToLibrary called but isPoolView is already false!');
                console.log('Current button states:');
                console.log('viewPoolBtn hidden:', viewPoolBtn.classList.contains('is-hidden'), 'disabled:', viewPoolBtn.disabled);
                console.log('backToLibraryBtn hidden:', backToLibraryBtn.classList.contains('is-hidden'), 'disabled:', backToLibraryBtn.disabled);
                // Force correct button state
                updateButtonVisibility();
                return;
            }

            isPoolView = false;
            console.log('Set isPoolView to false');

            // Update header back to normal library view
            updateLibraryTitle(false);

            // Don't clear search tags - preserve them
            // Don't clear tagSelectedImages - preserve tag selection status
            // Tags should only be removed when user explicitly removes them

            // Refresh library view (will show tag-filtered + manual selections)
            console.log('Calling displayLibraryImages...');
            displayLibraryImages().then(() => {
                console.log('displayLibraryImages completed successfully');
                console.log('tagSelectedImages after:', tagSelectedImages);
                console.log('=== backToLibrary END ===');
            }).catch(error => {
                console.error('Error in displayLibraryImages:', error);
                alert('Error returning to library. Please refresh the page.');
            });

        } catch (error) {
            console.error('Error in backToLibrary:', error);
            alert('Error returning to library. Please refresh the page.');
        }
    }

    function showProjectNameModal() {
        console.log('Selected images before modal:', selectedImages);

        // Safety check: Don't execute if no selections
        if (selectedImages.length === 0) {
            console.warn('showProjectNameModal called but no images are selected');
            alert('Please select at least one image.');
            return;
        }

        projectNameInput.value = '';
        projectNameModal.classList.remove('is-hidden');
        projectNameInput.focus();
    }

    function hideProjectNameModal() {
        projectNameModal.classList.add('is-hidden');
        projectNameInput.value = '';
    }

    function showProjectCreatedModal(projectName, imageCount) {
        projectSuccessMessage.textContent = `Project "${projectName}" created with ${imageCount} images! What would you like to do next?`;
        projectCreatedModal.classList.remove('is-hidden');
    }

    function hideProjectCreatedModal() {
        projectCreatedModal.classList.add('is-hidden');
        lastCreatedProject = null;
    }

    function showProjectDetailModal(project) {
        console.log('Opening project detail modal for:', project);

        // Update header information
        projectDetailName.textContent = `📁 ${project.name}`;
        projectDetailDate.textContent = `📅 Created: ${new Date(project.created_at).toLocaleDateString()}`;
        projectDetailCount.textContent = `📊 Total Images: ${project.image_ids.length}`;

        // Get unique tags from project images
        const projectTags = getProjectTags(project.image_ids);
        projectDetailTags.textContent = `🏷️ Tags: ${projectTags.join(', ') || 'No tags'}`;

        // Load project images
        loadProjectImages(project.image_ids);

        // Show modal
        projectDetailModal.classList.remove('is-hidden');
    }

    function hideProjectDetailModal() {
        projectDetailModal.classList.add('is-hidden');
        projectDetailGrid.innerHTML = '';
    }

    function getProjectTags(imageIds) {
        const allTags = new Set();
        imageIds.forEach(imageId => {
            const image = libraryImages.find(img => img.id === imageId);
            if (image && image.tags) {
                image.tags.forEach(tag => allTags.add(tag));
            }
        });
        return Array.from(allTags);
    }

    async function loadProjectImages(imageIds) {
        projectDetailGrid.innerHTML = '';

        try {
            // Get all images from API
            const response = await fetch(`${API_URL}/images`);
            if (!response.ok) throw new Error('Failed to fetch images');
            const allImages = await response.json();

            // Filter to only project images
            const projectImages = allImages.filter(img => imageIds.includes(img.id));

            projectImages.forEach(image => {
                const card = document.createElement('div');
                card.className = 'project-image-card';

                const img = document.createElement('img');
                img.src = `${API_URL}/${image.filepath.replace(/\\/g, '/')}`;
                img.alt = `Image ${image.id}`;

                // Add click handler for lightbox
                img.addEventListener('click', () => {
                    // Open lightbox for this image
                    openProjectImageLightbox(image, projectImages);
                });

                // Create icons container
                const iconsContainer = document.createElement('div');
                iconsContainer.className = 'project-image-icons';

                // Determine selection type and add appropriate icons
                const isTagSelected = tagSelectedImages.includes(image.id);
                const isManualSelected = selectedImages.includes(image.id) && !isTagSelected;

                if (isTagSelected) {
                    const tagIcon = document.createElement('div');
                    tagIcon.className = 'project-image-icon';
                    tagIcon.textContent = '🏷️';
                    tagIcon.title = 'Selected by tags';
                    iconsContainer.appendChild(tagIcon);
                }

                if (isManualSelected) {
                    const handIcon = document.createElement('div');
                    handIcon.className = 'project-image-icon';
                    handIcon.textContent = '👆';
                    handIcon.title = 'Manually selected';
                    iconsContainer.appendChild(handIcon);
                }

                card.appendChild(img);
                if (iconsContainer.children.length > 0) {
                    card.appendChild(iconsContainer);
                }

                projectDetailGrid.appendChild(card);
            });

        } catch (error) {
            console.error('Error loading project images:', error);
            projectDetailGrid.innerHTML = '<p>Error loading project images.</p>';
        }
    }

    function openProjectImageLightbox(image, projectImages) {
        // Set up lightbox for project images with proper src format
        const imageIndex = projectImages.findIndex(img => img.id === image.id);

        // Format project images for lightbox (add src property)
        const formattedImages = projectImages.map(img => ({
            ...img,
            src: `${API_URL}/${img.filepath.replace(/\\/g, '/')}`
        }));

        // Temporarily set for lightbox navigation
        libraryImages = formattedImages;
        openLibraryLightbox(imageIndex);
    }

    function filterProjects(searchTerm) {
        const projectCards = document.querySelectorAll('.project-card');
        projectCards.forEach(card => {
            const projectTitle = card.querySelector('.project-title').textContent.toLowerCase();
            if (projectTitle.includes(searchTerm)) {
                card.style.display = 'block';
            } else {
                card.style.display = 'none';
            }
        });
    }

    // Image Preview Overlay Functions
    function showImagePreviewOverlay(imageSrc, image) {
        // Set up regular library preview (no navigation)
        isSelectionPoolPreview = false;
        currentPreviewImages = [];
        currentPreviewIndex = 0;

        previewOverlayImg.src = imageSrc;
        previewOverlayImg.alt = `Full size preview of image ${image.id}`;

        // Reset scroll position to top-left
        imagePreviewOverlay.scrollTop = 0;
        imagePreviewOverlay.scrollLeft = 0;

        imagePreviewOverlay.classList.add('show');

        // Hide navigation arrows for regular library view
        previewNavLeft.classList.add('hidden');
        previewNavRight.classList.add('hidden');

        // Prevent body scrolling when overlay is open (but allow overlay scrolling)
        document.body.style.overflow = 'hidden';

        // Add pan event listeners
        addPanEventListeners();

        console.log('Regular image preview overlay opened for image:', image.id);
    }

    function hideImagePreviewOverlay() {
        imagePreviewOverlay.classList.remove('show');
        previewOverlayImg.src = '';

        // Restore body scrolling
        document.body.style.overflow = '';

        // Remove pan event listeners
        removePanEventListeners();

        // Reset Selection Pool preview state
        isSelectionPoolPreview = false;
        currentPreviewImages = [];
        currentPreviewIndex = 0;

        // Hide navigation arrows
        previewNavLeft.classList.add('hidden');
        previewNavRight.classList.add('hidden');
    }

    // Pan functionality variables
    let isPanning = false;
    let startX = 0;
    let startY = 0;
    let scrollLeft = 0;
    let scrollTop = 0;

    // Pan functionality functions
    function addPanEventListeners() {
        imagePreviewOverlay.addEventListener('mousedown', startPan);
        imagePreviewOverlay.addEventListener('mousemove', doPan);
        imagePreviewOverlay.addEventListener('mouseup', endPan);
        imagePreviewOverlay.addEventListener('mouseleave', endPan);

        // Prevent default drag behavior on images
        previewOverlayImg.addEventListener('dragstart', (e) => e.preventDefault());
    }

    function removePanEventListeners() {
        imagePreviewOverlay.removeEventListener('mousedown', startPan);
        imagePreviewOverlay.removeEventListener('mousemove', doPan);
        imagePreviewOverlay.removeEventListener('mouseup', endPan);
        imagePreviewOverlay.removeEventListener('mouseleave', endPan);
    }

    function startPan(e) {
        // Don't start panning if clicking on the close button
        if (e.target.id === 'preview-overlay-close') return;

        isPanning = true;
        imagePreviewOverlay.classList.add('panning');

        startX = e.clientX;
        startY = e.clientY;
        scrollLeft = imagePreviewOverlay.scrollLeft;
        scrollTop = imagePreviewOverlay.scrollTop;

        e.preventDefault();
    }

    function doPan(e) {
        if (!isPanning) return;

        e.preventDefault();

        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;

        imagePreviewOverlay.scrollLeft = scrollLeft - deltaX;
        imagePreviewOverlay.scrollTop = scrollTop - deltaY;
    }

    function endPan() {
        isPanning = false;
        imagePreviewOverlay.classList.remove('panning');
    }

    // Selection Pool Preview Functions
    function showSelectionPoolPreview(clickedImage, allImages, clickedIndex) {
        console.log('showSelectionPoolPreview called with:', {
            clickedImage: clickedImage.id,
            allImagesCount: allImages.length,
            clickedIndex: clickedIndex
        });

        // Set up navigation data
        currentPreviewImages = allImages;
        currentPreviewIndex = clickedIndex;
        isSelectionPoolPreview = true;

        // Show the clicked image
        const imageSrc = `${API_URL}/${clickedImage.filepath.replace(/\\/g, '/')}`;
        previewOverlayImg.src = imageSrc;
        previewOverlayImg.alt = `Full size preview of image ${clickedImage.id}`;

        // Reset scroll position to top-left
        imagePreviewOverlay.scrollTop = 0;
        imagePreviewOverlay.scrollLeft = 0;

        // Show overlay first
        imagePreviewOverlay.classList.add('show');

        // Update navigation arrows visibility (after overlay is shown)
        updateNavigationArrows();

        // Prevent body scrolling and add pan functionality
        document.body.style.overflow = 'hidden';
        addPanEventListeners();

        console.log('Selection Pool preview opened for image:', clickedImage.id, 'at index:', clickedIndex);
        console.log('Navigation arrows should be visible now');
    }

    function updateNavigationArrows() {
        console.log('updateNavigationArrows called:', {
            currentPreviewIndex: currentPreviewIndex,
            totalImages: currentPreviewImages.length,
            isSelectionPoolPreview: isSelectionPoolPreview
        });

        if (!isSelectionPoolPreview) {
            // Hide arrows for regular library preview
            previewNavLeft.classList.add('hidden');
            previewNavRight.classList.add('hidden');
            console.log('Hiding arrows - not Selection Pool preview');
            return;
        }

        // Show/hide arrows based on current position in Selection Pool
        if (currentPreviewIndex <= 0) {
            previewNavLeft.classList.add('hidden');
            console.log('Hiding left arrow - at first image');
        } else {
            previewNavLeft.classList.remove('hidden');
            console.log('Showing left arrow');
        }

        if (currentPreviewIndex >= currentPreviewImages.length - 1) {
            previewNavRight.classList.add('hidden');
            console.log('Hiding right arrow - at last image');
        } else {
            previewNavRight.classList.remove('hidden');
            console.log('Showing right arrow');
        }

        console.log('Navigation arrows updated');
    }

    function navigatePreview(direction) {
        if (!isSelectionPoolPreview) return;

        let newIndex = currentPreviewIndex;

        if (direction === 'left' && currentPreviewIndex > 0) {
            newIndex = currentPreviewIndex - 1;
        } else if (direction === 'right' && currentPreviewIndex < currentPreviewImages.length - 1) {
            newIndex = currentPreviewIndex + 1;
        }

        if (newIndex !== currentPreviewIndex) {
            currentPreviewIndex = newIndex;
            const newImage = currentPreviewImages[newIndex];
            const newImageSrc = `${API_URL}/${newImage.filepath.replace(/\\/g, '/')}`;

            previewOverlayImg.src = newImageSrc;
            previewOverlayImg.alt = `Full size preview of image ${newImage.id}`;

            // Reset scroll position for new image
            imagePreviewOverlay.scrollTop = 0;
            imagePreviewOverlay.scrollLeft = 0;

            // Update arrow visibility
            updateNavigationArrows();

            console.log('Navigated to image:', newImage.id, 'at index:', newIndex);
        }
    }

    async function createProject() {
        const projectName = projectNameInput.value.trim();
        console.log('Creating project with selected images:', selectedImages);

        if (!projectName) {
            alert('Please enter a project name.');
            return;
        }

        // Check if we have selected images
        if (selectedImages.length === 0) {
            alert('Please select at least one image before creating a project.');
            return;
        }

        // Check if project name already exists
        if (projects.some(p => p.name.toLowerCase() === projectName.toLowerCase())) {
            alert('A project with this name already exists.');
            return;
        }

        // Store the count before clearing selection
        const imageCount = selectedImages.length;

        try {
            const newProject = await saveProjectToAPI(projectName, [...selectedImages]);
            displayProjects();

            // Store the created project for navigation
            lastCreatedProject = newProject;

            // Hide project name modal first, then clear selection
            hideProjectNameModal();
            deselectAllImages();

            // Show success confirmation modal
            showProjectCreatedModal(projectName, imageCount);
        } catch (error) {
            alert('Failed to create project. Please try again.');
        }
    }

    async function loadProjectsFromAPI() {
        try {
            const response = await fetch(`${API_URL}/projects`);
            if (response.ok) {
                projects = await response.json();
                console.log('Loaded projects from API:', projects.length);
            } else {
                console.error('Failed to load projects:', response.statusText);
                projects = [];
            }
        } catch (error) {
            console.error('Error loading projects:', error);
            projects = [];
        }
    }

    async function saveProjectToAPI(projectName, imageIds) {
        try {
            const response = await fetch(`${API_URL}/projects`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    name: projectName,
                    image_ids: imageIds
                })
            });

            if (response.ok) {
                const newProject = await response.json();
                projects.push(newProject);
                console.log('Project saved to API:', newProject);
                return newProject;
            } else {
                console.error('Failed to save project:', response.statusText);
                throw new Error('Failed to save project');
            }
        } catch (error) {
            console.error('Error saving project:', error);
            throw error;
        }
    }

    async function deleteProjectFromAPI(projectId) {
        try {
            const response = await fetch(`${API_URL}/projects/${projectId}`, {
                method: 'DELETE'
            });

            if (response.ok) {
                projects = projects.filter(p => p.id !== projectId);
                console.log('Project deleted from API:', projectId);
                return true;
            } else {
                console.error('Failed to delete project:', response.statusText);
                throw new Error('Failed to delete project');
            }
        } catch (error) {
            console.error('Error deleting project:', error);
            throw error;
        }
    }

    async function displayProjects() {
        if (projects.length === 0) {
            projectList.innerHTML = '<p class="text">No projects created yet. Select images in the Image Library and click "Add to Project" to create your first project.</p>';
            return;
        }

        projectList.innerHTML = '';

        // Sort projects by creation date - latest first (top-left corner)
        const sortedProjects = [...projects].sort((a, b) => {
            // Sort by ID in descending order (assuming higher ID = more recent)
            return b.id - a.id;
        });

        for (const project of sortedProjects) {
            const projectCard = document.createElement('div');
            projectCard.className = 'project-card';

            // Project card header with title and metadata
            const cardHeader = document.createElement('div');
            cardHeader.className = 'project-card-header';

            const titleSection = document.createElement('div');
            titleSection.className = 'project-title-section';

            const projectTitle = document.createElement('h3');
            projectTitle.className = 'project-title';
            projectTitle.textContent = project.name;

            const projectMeta = document.createElement('div');
            projectMeta.className = 'project-meta';

            const imageCount = document.createElement('span');
            imageCount.className = 'project-image-count';
            imageCount.textContent = `${project.image_ids.length} images`;

            const createdDate = document.createElement('span');
            createdDate.className = 'project-created-date';
            const date = new Date(project.created_at);
            createdDate.textContent = `Created ${date.toLocaleDateString()} at ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;

            projectMeta.appendChild(imageCount);
            projectMeta.appendChild(createdDate);
            titleSection.appendChild(projectTitle);
            titleSection.appendChild(projectMeta);

            const actionSection = document.createElement('div');
            actionSection.className = 'project-actions';

            const shareBtn = document.createElement('button');
            shareBtn.className = 'button share-project-btn';
            shareBtn.innerHTML = '';
            shareBtn.title = 'Share project via email';
            shareBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering project detail modal
                showShareProjectModal(project);
            });

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'button delete-project-btn';
            deleteBtn.innerHTML = '🗑️';
            deleteBtn.title = 'Delete project';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering project detail modal
                deleteProject(project.id);
            });

            actionSection.appendChild(shareBtn);
            actionSection.appendChild(deleteBtn);
            cardHeader.appendChild(titleSection);
            cardHeader.appendChild(actionSection);

            // Project images preview (first few images)
            const projectPreview = document.createElement('div');
            projectPreview.className = 'project-preview';

            // Get image data for this project
            try {
                const response = await fetch(`${API_URL}/images`);
                const allImages = await response.json();
                const projectImageData = allImages.filter(img => project.image_ids.includes(img.id));

                // Show first 6 images as preview
                const previewImages = projectImageData.slice(0, 6);
                previewImages.forEach(image => {
                    const previewImg = document.createElement('img');
                    previewImg.className = 'project-preview-image';
                    previewImg.src = `${API_URL}/${image.filepath.replace(/\\/g, '/')}`;
                    projectPreview.appendChild(previewImg);
                });

                // Add "more" indicator if there are more images
                if (projectImageData.length > 6) {
                    const moreIndicator = document.createElement('div');
                    moreIndicator.className = 'project-more-indicator';
                    moreIndicator.textContent = `+${projectImageData.length - 6} more`;
                    projectPreview.appendChild(moreIndicator);
                }
            } catch (error) {
                console.error('Error loading project images:', error);
            }

            // Add click handler to open project detail modal
            projectCard.addEventListener('click', () => {
                showProjectDetailModal(project);
            });

            // Make project card look clickable
            projectCard.style.cursor = 'pointer';

            projectCard.appendChild(cardHeader);
            projectCard.appendChild(projectPreview);
            projectList.appendChild(projectCard);
        }
    }

    async function deleteProject(projectId) {
        const project = projects.find(p => p.id === projectId);
        if (project && confirm(`Are you sure you want to delete the project "${project.name}"?`)) {
            try {
                await deleteProjectFromAPI(projectId);
                displayProjects();
            } catch (error) {
                alert('Failed to delete project. Please try again.');
            }
        }
    }

    // Share Project Functions
    function showShareProjectModal(project) {
        shareProjectName.textContent = project.name;
        shareEmailInput.value = '';
        shareMessageInput.value = '';
        shareProjectModal.classList.remove('is-hidden');
        shareEmailInput.focus();

        // Store project data for sharing
        shareProjectModal.dataset.projectId = project.id;
        shareProjectModal.dataset.projectName = project.name;
    }

    function hideShareProjectModal() {
        shareProjectModal.classList.add('is-hidden');
        shareEmailInput.value = '';
        shareMessageInput.value = '';
        delete shareProjectModal.dataset.projectId;
        delete shareProjectModal.dataset.projectName;
    }

    async function shareProject() {
        const email = shareEmailInput.value.trim();
        const message = shareMessageInput.value.trim();
        const projectId = shareProjectModal.dataset.projectId;
        const projectName = shareProjectModal.dataset.projectName;

        if (!email) {
            alert('Please enter a recipient email address.');
            shareEmailInput.focus();
            return;
        }

        if (!email.includes('@') || !email.includes('.')) {
            alert('Please enter a valid email address.');
            shareEmailInput.focus();
            return;
        }

        // Show loading state and overlay
        sendShareBtn.disabled = true;
        sendShareBtn.textContent = 'Sending...';
        hideShareProjectModal();
        emailSendingOverlay.classList.remove('is-hidden');

        try {
            const response = await fetch(`${API_URL}/projects/${projectId}/share`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    recipient_email: email,
                    message: message
                })
            });

            if (response.ok) {
                emailSendingOverlay.classList.add('is-hidden');
                alert(`Project "${projectName}" has been shared successfully with ${email}!`);
            } else {
                const error = await response.text();
                throw new Error(error || 'Failed to share project');
            }
        } catch (error) {
            console.error('Error sharing project:', error);
            emailSendingOverlay.classList.add('is-hidden');
            alert('Failed to share project. Please try again.');
        } finally {
            // Reset button state
            sendShareBtn.disabled = false;
            sendShareBtn.textContent = 'Send Email';
            emailSendingOverlay.classList.add('is-hidden');
        }
    }

    // --- Event Listeners ---

    navLinks.library.addEventListener('click', (e) => { e.preventDefault(); navigateTo('library'); });
    navLinks.upload.addEventListener('click', (e) => { e.preventDefault(); navigateTo('upload'); });
    navLinks.project.addEventListener('click', (e) => { e.preventDefault(); navigateTo('project'); });

    fileInput.addEventListener('change', (event) => {
        handleFiles(event.target.files);
    });

    clearAllButton.addEventListener('click', () => {
        previewGrid.innerHTML = '';
        filesToUpload = [];
        fileInput.value = '';
    });

    subjInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === 'Tab' || e.key === ',') {
            e.preventDefault();
            handleSubjCommit();
        } else if (e.key === 'Backspace' && subjInput.value === '') {
            const chips = subjChips.querySelectorAll('.chip');
            const last = chips[chips.length - 1];
            if (last) subjChips.removeChild(last);
        }
    });

    // Add event listeners for all objective metadata inputs
    [objBookInput, objPageInput, objRowInput, objColumnInput, objTypeInput, objMaterialInput, objDimensionInput, objRemarkInput, objBrandInput, objColorInput].forEach(input => {
        if (input) {
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === 'Tab' || e.key === ',') {
                    e.preventDefault();
                    handleObjCommit(input);
                }
            });
        }
    });

    // Auto-fill button event listener
    autoFillBtn.addEventListener('click', autoFillMetadata);

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropzone.addEventListener(eventName, (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, false);
    });
    ['dragenter', 'dragover'].forEach(eventName => {
        dropzone.addEventListener(eventName, () => dropzone.classList.add('is-dragover'), false);
    });
    ['dragleave', 'drop'].forEach(eventName => {
        dropzone.addEventListener(eventName, () => dropzone.classList.remove('is-dragover'), false);
    });
    dropzone.addEventListener('drop', (e) => {
        handleFiles(e.dataTransfer.files);
    }, false);

    window.addEventListener('paste', (e) => {
        if (pages.upload.classList.contains('is-hidden')) return;
        handleFiles(e.clipboardData.files);
        dropzone.classList.add('is-dragover');
        setTimeout(() => dropzone.classList.remove('is-dragover'), 150);
    });

    prevButton.addEventListener('click', () => {
        if (libraryImages.length > 0) {
            showLibraryImage(currentImageIndex - 1);
        } else {
            showImage(currentImageIndex - 1);
        }
    });

    nextButton.addEventListener('click', () => {
        if (libraryImages.length > 0) {
            showLibraryImage(currentImageIndex + 1);
        } else {
            showImage(currentImageIndex + 1);
        }
    });

    closeModal.addEventListener('click', hideModal);

    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            hideModal();
        }
    });

    // Add keyboard support for Escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !modal.classList.contains('is-hidden')) {
            hideModal();
        }
    });

    const loadingOverlay = document.getElementById('loading-overlay');
    const confirmModal = document.getElementById('confirm-modal');
    const uploadMoreBtn = document.getElementById('upload-more-btn');
    const goToLibraryBtn = document.getElementById('go-to-library-btn');

    function clearUploadUI() {
        previewGrid.innerHTML = '';
        subjChips.innerHTML = '';
        objChips.innerHTML = '';

        // Clear all objective metadata inputs
        [objBookInput, objPageInput, objRowInput, objColumnInput, objTypeInput, objMaterialInput, objDimensionInput, objRemarkInput, objBrandInput, objColorInput].forEach(input => {
            if (input) input.value = '';
        });

        filesToUpload = [];
        fileInput.value = '';
    }

    uploadMoreBtn.addEventListener('click', () => {
        confirmModal.classList.add('is-hidden');
        clearUploadUI();
        uploadButton.disabled = false; // Re-enable
    });

    goToLibraryBtn.addEventListener('click', () => {
        confirmModal.classList.add('is-hidden');
        clearUploadUI();
        uploadButton.disabled = false; // Re-enable
        navigateTo('library');
    });

    uploadButton.addEventListener('click', async () => {
        const subjTags = Array.from(subjChips.querySelectorAll('.chip')).map(chip => chip.textContent.replace(/[×x]$/, '').trim());
        const objTags = Array.from(objChips.querySelectorAll('.chip')).map(chip => chip.textContent.replace(/[×x]$/, '').trim());
        const allTags = [...subjTags, ...objTags];

        if (filesToUpload.length === 0) {
            return alert('Please select images to upload.');
        }

        const formData = new FormData();
        filesToUpload.forEach(file => {
            formData.append('images', file);
        });
        formData.append('tags', JSON.stringify(allTags));

        uploadButton.disabled = true;
        loadingOverlay.classList.remove('is-hidden');

        try {
            const response = await fetch(`${API_URL}/upload`, {
                method: 'POST',
                body: formData
            });

            loadingOverlay.classList.add('is-hidden');

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Upload failed: ${errorText}`);
            }

            // On success, show the custom confirmation dialog
            confirmModal.classList.remove('is-hidden');

        } catch (error) {
            console.error('Error uploading images:', error);
            alert(`An error occurred during upload. Please try again. Details: ${error.message}`);
            loadingOverlay.classList.add('is-hidden');
            uploadButton.disabled = false;
        }
    });





    // Handle tag input with Enter, Tab, or comma
    librarySearchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === 'Tab' || e.key === ',') {
            e.preventDefault();
            handleSearchTagCommit();
        }
        // Note: Backspace functionality for removing tag chips has been disabled
        // Users must use the "x" button on individual chips or "Clear All" button
    });

    // Also handle input changes for real-time search
    librarySearchInput.addEventListener('input', (e) => {
        // If user clears the input, clear all chips
        if (e.target.value === '') {
            clearAllSearchChips();
        }
    });

    // Ensure input is fresh on focus
    librarySearchInput.addEventListener('focus', () => {
        // Clear any browser-suggested values on focus
        setTimeout(() => {
            if (librarySearchInput.value && searchTags.length === 0) {
                librarySearchInput.value = '';
            }
        }, 0);
    });

    // Prevent browser from storing values
    librarySearchInput.addEventListener('blur', () => {
        // Don't let browser remember the value
        librarySearchInput.setAttribute('autocomplete', 'new-password');
        setTimeout(() => {
            librarySearchInput.setAttribute('autocomplete', 'off');
        }, 100);
    });

    function handleSearchTagCommit() {
        const inputValue = librarySearchInput.value.trim();
        if (!inputValue) return;

        // Split by comma and add each tag as a chip
        const newTags = inputValue.split(',').map(tag => tag.trim()).filter(tag => tag);
        newTags.forEach(tagText => {
            addSearchTagChip(tagText, true); // Default to has matches, will be updated
        });

        // Clear input and refresh search
        librarySearchInput.value = '';
        displayLibraryImages();
    }

    searchModeRadios.forEach(radio => radio.addEventListener('change', displayLibraryImages));

    // Clear all button (clears both tags and selected images)
    clearAllTagsBtn.addEventListener('click', () => {
        clearAllSearchChips();
    });

    // Initialize button state
    updateClearButtonState();





    // Initialize search input to be completely fresh
    initializeFreshSearchInput();

    // Selection and project event listeners
    selectAllBtn.addEventListener('click', selectAllImages);
    deselectAllBtn.addEventListener('click', deselectAllImages);
    viewPoolBtn.addEventListener('click', handleViewPoolClick);
    backToLibraryBtn.addEventListener('click', backToLibrary);
    addToProjectBtn.addEventListener('click', showProjectNameModal);
    cancelProjectBtn.addEventListener('click', hideProjectNameModal);
    createProjectBtn.addEventListener('click', createProject);

    // Project created confirmation modal event listeners
    addMoreProjectsBtn.addEventListener('click', () => {
        hideProjectCreatedModal();
        // Stay in current view to allow selecting more images for another project
        console.log('User chose to add more projects');
    });

    goToProjectBtn.addEventListener('click', () => {
        hideProjectCreatedModal();
        // Navigate to the project page
        navigateTo('project');
        console.log('User chose to go to project page');
    });

    // Project detail modal event listeners
    closeProjectDetailBtn.addEventListener('click', hideProjectDetailModal);

    // Project search functionality
    projectSearchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase();
        filterProjects(searchTerm);
    });

    projectFilterBtn.addEventListener('click', () => {
        // Future: Add advanced filtering options
        console.log('Filter button clicked - future feature');
    });

    // Image preview overlay event listeners
    previewOverlayClose.addEventListener('click', hideImagePreviewOverlay);

    // Close overlay when clicking outside the image
    imagePreviewOverlay.addEventListener('click', (e) => {
        if (e.target === imagePreviewOverlay) {
            hideImagePreviewOverlay();
        }
    });

    // Navigation arrow event listeners
    previewNavLeft.addEventListener('click', () => {
        navigatePreview('left');
    });

    previewNavRight.addEventListener('click', () => {
        navigatePreview('right');
    });

    // Close overlay with Escape key and add arrow key scrolling/navigation
    document.addEventListener('keydown', (e) => {
        if (imagePreviewOverlay.classList.contains('show')) {
            if (e.key === 'Escape') {
                hideImagePreviewOverlay();
            } else if (isSelectionPoolPreview && e.key === 'ArrowLeft') {
                e.preventDefault();
                navigatePreview('left');
            } else if (isSelectionPoolPreview && e.key === 'ArrowRight') {
                e.preventDefault();
                navigatePreview('right');
            } else if (!isSelectionPoolPreview && e.key === 'ArrowUp') {
                e.preventDefault();
                imagePreviewOverlay.scrollTop -= 50;
            } else if (!isSelectionPoolPreview && e.key === 'ArrowDown') {
                e.preventDefault();
                imagePreviewOverlay.scrollTop += 50;
            } else if (!isSelectionPoolPreview && e.key === 'ArrowLeft') {
                e.preventDefault();
                imagePreviewOverlay.scrollLeft -= 50;
            } else if (!isSelectionPoolPreview && e.key === 'ArrowRight') {
                e.preventDefault();
                imagePreviewOverlay.scrollLeft += 50;
            }
        }
    });

    // Project name input enter key
    projectNameInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            createProject();
        } else if (e.key === 'Escape') {
            hideProjectNameModal();
        }
    });

    // Share project modal event listeners
    shareProjectClose.addEventListener('click', hideShareProjectModal);
    cancelShareBtn.addEventListener('click', hideShareProjectModal);
    sendShareBtn.addEventListener('click', shareProject);

    // Share email input enter key (only Enter, no ESC)
    shareEmailInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            shareProject();
        }
    });

    // Load projects on startup
    loadProjectsFromAPI().then(() => {
        displayProjects();
    });


  </script>
</body>
</html>

