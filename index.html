<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Image Library â€” Minimal Shell</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="app">
    <aside class="sidebar" aria-label="Main menu">
      <div class="brand">
        <div class="hamburger">
          <div class="hamburger__line"></div>
          <div class="hamburger__line"></div>
          <div class="hamburger__line"></div>
        </div>
        <span>Image Library</span>
      </div>
      <nav class="menu">
        <a id="nav-library" class="menu__item is-active" href="#">Image Library</a>
        <a id="nav-upload" class="menu__item" href="#">Upload Image</a>
        <a id="nav-tags" class="menu__item" href="#">Tags</a>
        <a id="nav-settings" class="menu__item" href="#">Settings</a>
      </nav>

      <div class="version-wrapper">
          <span class="version">v2.3.4</span>
      </div>

      <div class="sidebar__footer">
        <button class="button button--primary" type="button">Login</button>
      </div>
    </aside>

    <main class="content">
      <!-- Image Library Page (Default) -->
      <div id="page-library" class="page">
        <header class="content__header">
          <h1 class="title">Image Library</h1>
          <div class="legend" style="margin-top:8px;">Solid = Objective, Dashed = Subjective</div>
        </header>
        <section class="panel">
          <div class="search-bar">
            <div class="search-input-row">
              <input type="text" id="library-search-input" placeholder="Enter tags separated by commas...">
              <button id="clear-all-tags" class="button clear-tags-btn" type="button">Clear All Tags</button>
            </div>
            <div id="library-search-chips" class="chips search-chips"></div>
            <div class="search-options">
              <label><input type="radio" name="search-mode" value="AND" checked> AND (all tags must match)</label>
              <label><input type="radio" name="search-mode" value="OR"> OR (any tag can match)</label>
            </div>
          </div>
          <div id="library-grid" class="preview-grid"></div>
        </section>
      </div>

      <!-- Upload Image Page -->
      <div id="page-upload" class="page is-hidden">
          <header class="content__header">
            <h1 class="title">Upload Images</h1>
          </header>
          <section class="panel">
            <div id="dropzone" class="upload-area">
              <div class="preview-header">
                <h2 class="panel__title">Selected Images</h2>
                <div class="upload-actions">
                  <input type="file" id="file-input" class="file-input" multiple />
                  <label for="file-input" class="button">Browse Files</label>
                  <button id="clear-all" class="button" type="button">Clear All</button>
                </div>
              </div>
              <p class="text">Browse, drag & drop, or paste images</p>
              <div id="preview-grid" class="preview-grid"></div>
            </div>
            <div class="upload-actions">
                <button id="upload-button" class="button button--primary" type="button">Upload</button>
            </div>
          </section>

          <!-- Layer 3: Tag panels -->
          <section class="panel">
            <div class="apply-scope">
              Apply to: <button id="apply-all" class="button" type="button">All images</button>
              <button id="apply-selected" class="button" type="button">Selected only</button>
              <span class="legend">Solid = Objective, Dashed = Subjective</span>
            </div>

            <div class="tag-panels">
              <div class="tag-panel tag-panel--objective">
                <div class="tag-panel__header is-objective">OBJECTIVE (FACTS)</div>
                <div class="tag-panel__body">
                  <label class="tag-input">
                    brand: <input id="obj-brand" type="text" placeholder="brand:nike" />
                  </label>
                  <label class="tag-input">
                    color: <input id="obj-color" type="text" placeholder="color:red" />
                  </label>
                  <div id="obj-chips" class="chips"></div>
                </div>
              </div>

              <div class="tag-panel tag-panel--subjective">
                <div class="tag-panel__header is-subjective">SUBJECTIVE (FEELINGS)</div>
                <div class="tag-panel__body">
                  <div class="subj-inline">
                    <div>
                      <label class="tag-input">Add feelings:
                        <input id="subj-input" type="text" placeholder="type and press Enter/Tab" />
                      </label>
                      <div class="hint">Press Enter or Tab to add; Backspace removes last when empty</div>
                    </div>
                    <div id="subj-chips" class="chips"></div>
                  </div>
                </div>
              </div>
            </div>
          </section>
      </div>
    </main>
  </div>





  <!-- Lightbox Modal -->
  <div id="lightbox-modal" class="modal is-hidden">
    <span class="modal-close">&times;</span>
    <a class="prev">&#10094;</a>
    <div class="lightbox-content">
      <img class="modal-content" id="lightbox-image">
      <div id="lightbox-tags" class="lightbox-tags"></div>
    </div>
    <a class="next">&#10095;</a>
  </div>

      <!-- Confirmation Dialog -->
      <div id="confirm-modal" class="modal is-hidden">
        <div class="modal-content-text">
          <p>Upload Successful! What would you like to do next?</p>
          <div class="modal-buttons">
            <button id="upload-more-btn" class="button">Upload More</button>
            <button id="go-to-library-btn" class="button is-primary">Go to Library</button>
          </div>
        </div>
      </div>



      <!-- Loading Overlay -->
      <div id="loading-overlay" class="modal is-hidden">
        <div class="modal-content-text">
          Uploading... Please wait.
        </div>
      </div>

  <script>
    // --- Constants & State ---
    const API_URL = 'http://localhost:3000';
    const navLinks = {
        library: document.getElementById('nav-library'),
        upload: document.getElementById('nav-upload'),
    };
    const pages = {
        library: document.getElementById('page-library'),
        upload: document.getElementById('page-upload'),
    };
    const fileInput = document.getElementById('file-input');
    const previewGrid = document.getElementById('preview-grid');
    const clearAllButton = document.getElementById('clear-all');
    const dropzone = document.getElementById('dropzone');
    const subjInput = document.getElementById('subj-input');
    const subjChips = document.getElementById('subj-chips');
    const modal = document.getElementById('lightbox-modal');
    const modalImg = document.getElementById('lightbox-image');
    const lightboxTags = document.getElementById('lightbox-tags');
    const closeModal = document.querySelector('.modal-close');
    const prevButton = document.querySelector('.prev');
    const nextButton = document.querySelector('.next');
    const uploadButton = document.getElementById('upload-button');
    const librarySearchInput = document.getElementById('library-search-input');
    const libraryGrid = document.getElementById('library-grid');
    const librarySearchChips = document.getElementById('library-search-chips');
    const clearAllTagsBtn = document.getElementById('clear-all-tags');
    const searchModeRadios = document.querySelectorAll('input[name="search-mode"]');

    let filesToUpload = [];
    let currentImageIndex = 0;
    let imageSources = [];
    let libraryImages = []; // Store current library images for lightbox navigation
    let searchTags = []; // Store current search tags as chips

    // --- Function Definitions ---

    async function displayLibraryImages() {
        const searchMode = document.querySelector('input[name="search-mode"]:checked').value;
        const currentSearchTags = searchTags.map(tag => tag.text);

        try {
            const response = await fetch(`${API_URL}/images?tags=${currentSearchTags.join(',')}&mode=${searchMode}`);
            const images = await response.json();

            libraryGrid.innerHTML = '';
            libraryImages = []; // Reset library images array

            // Check which tags have matches and update chip colors
            await updateTagChipColors(currentSearchTags, searchMode);

            images.forEach((image, index) => {
                const card = document.createElement('div');
                card.className = 'preview-card library-card';
                const img = document.createElement('img');
                const imageSrc = `${API_URL}/${image.filepath.replace(/\\/g, '/')}`;
                img.src = imageSrc;

                // Store image data for lightbox navigation
                libraryImages.push({
                    src: imageSrc,
                    index: index,
                    tags: image.tags || []
                });

                // Add click event listener for lightbox
                img.addEventListener('click', () => {
                    openLibraryLightbox(index);
                });

                // Add cursor pointer style
                img.style.cursor = 'pointer';

                card.appendChild(img);

                // Add tag overlay if there are matching tags
                const matchingTags = getMatchingTags(image.tags || [], currentSearchTags);
                if (matchingTags.length > 0) {
                    const tagOverlay = document.createElement('div');
                    tagOverlay.className = 'tag-overlay';
                    tagOverlay.textContent = matchingTags.join(', ');
                    card.appendChild(tagOverlay);
                }

                libraryGrid.appendChild(card);
            });
        } catch (error) {
            console.error('Error fetching images:', error);
        }
    }

    async function updateTagChipColors(tags, searchMode) {
        for (const tagText of tags) {
            try {
                const response = await fetch(`${API_URL}/images?tags=${tagText}&mode=OR`);
                const images = await response.json();
                const hasMatches = images.length > 0;

                // Update the chip color based on matches
                const chip = Array.from(librarySearchChips.querySelectorAll('.search-chip')).find(
                    chip => chip.textContent.replace('x', '').trim() === tagText
                );

                if (chip) {
                    if (hasMatches) {
                        chip.classList.remove('no-matches');
                        chip.classList.add('has-matches');
                    } else {
                        chip.classList.remove('has-matches');
                        chip.classList.add('no-matches');
                    }
                }

                // Update searchTags array
                const tagIndex = searchTags.findIndex(tag => tag.text === tagText);
                if (tagIndex !== -1) {
                    searchTags[tagIndex].hasMatches = hasMatches;
                }
            } catch (error) {
                console.error(`Error checking matches for tag "${tagText}":`, error);
            }
        }
    }

    function navigateTo(pageName) {
        const confirmModal = document.getElementById('confirm-modal');
        // Do not navigate if the confirmation modal is visible
        if (confirmModal && !confirmModal.classList.contains('is-hidden')) {
            return;
        }
        Object.values(pages).forEach(page => page.classList.add('is-hidden'));
        document.querySelectorAll('.menu__item').forEach(link => link.classList.remove('is-active'));
        pages[pageName].classList.remove('is-hidden');
        navLinks[pageName].classList.add('is-active');

        if (pageName === 'library') {
            displayLibraryImages();
        }
    }

    function handleFiles(files) {
        for (const file of files) {
            if (!file.type.startsWith('image/')) continue;
            filesToUpload.push(file);

            const reader = new FileReader();
            reader.onload = (e) => {
                const card = document.createElement('div');
                card.className = 'preview-card';

                const img = document.createElement('img');
                img.src = e.target.result;
                img.addEventListener('click', (event) => {
                    const allImages = Array.from(previewGrid.querySelectorAll('img'));
                    const clickedIndex = allImages.indexOf(event.target);
                    openModal(clickedIndex);
                });

                const del = document.createElement('button');
                del.type = 'button';
                del.className = 'delete-btn';
                del.textContent = 'x';
                del.addEventListener('click', () => {
                    const indexToRemove = filesToUpload.indexOf(file);
                    if (indexToRemove > -1) {
                        filesToUpload.splice(indexToRemove, 1);
                    }
                    card.remove();
                });

                card.appendChild(del);
                card.appendChild(img);
                previewGrid.appendChild(card);
            };
            reader.readAsDataURL(file);
        }
    }

    function addSubjChip(label) {
        const text = (label || '').toLowerCase().trim();
        if (!text) return;
        if ([...subjChips.querySelectorAll('.chip')].some(c => c.textContent.replace(/x$/, '').trim() === text)) return;
        const chip = document.createElement('span');
        chip.className = 'chip is-subjective';
        chip.textContent = text;
        chip.tabIndex = 0;
        chip.addEventListener('click', () => chip.classList.toggle('is-selected'));
        const x = document.createElement('button');
        x.type = 'button';
        x.className = 'x';
        x.textContent = 'x';
        x.addEventListener('click', (ev) => { ev.stopPropagation(); chip.remove(); });
        chip.appendChild(x);
        subjChips.appendChild(chip);
    }

    function handleSubjCommit() {
        const parts = subjInput.value.split(',');
        parts.forEach(p => addSubjChip(p));
        subjInput.value = '';
    }

    function updateArrowVisibility() {
        const totalImages = imageSources.length;
        prevButton.style.display = (currentImageIndex > 0 && totalImages > 1) ? 'block' : 'none';
        nextButton.style.display = (currentImageIndex < totalImages - 1 && totalImages > 1) ? 'block' : 'none';
    }

    function openModal(index) {
        currentImageIndex = index;
        imageSources = Array.from(previewGrid.querySelectorAll('img')).map(img => img.src);
        modalImg.src = imageSources[currentImageIndex];
        modal.classList.remove('is-hidden');
        updateArrowVisibility();
    }

    function showImage(index) {
        if (index >= imageSources.length || index < 0) return;
        currentImageIndex = index;
        modalImg.src = imageSources[currentImageIndex];
        updateArrowVisibility();
    }

    function hideModal() {
        modal.classList.add('is-hidden');
    }

    // --- Library Lightbox Functions ---

    function openLibraryLightbox(index) {
        currentImageIndex = index;
        imageSources = libraryImages.map(img => img.src);
        modalImg.src = imageSources[currentImageIndex];
        displayLightboxTags(index);
        modal.classList.remove('is-hidden');
        updateArrowVisibility();
    }

    function showLibraryImage(index) {
        if (index >= imageSources.length || index < 0) return;
        currentImageIndex = index;
        modalImg.src = imageSources[currentImageIndex];
        displayLightboxTags(index);
        updateArrowVisibility();
    }

    // --- Search Tag Chip Functions ---

    function addSearchTagChip(tagText, hasMatches = true) {
        const text = tagText.toLowerCase().trim();
        if (!text) return;

        // Check if tag already exists
        if (searchTags.some(tag => tag.text === text)) return;

        // Add to searchTags array
        searchTags.push({ text: text, hasMatches: hasMatches });

        // Create chip element
        const chip = document.createElement('span');
        chip.className = hasMatches ? 'chip search-chip' : 'chip search-chip no-matches';
        chip.textContent = text;
        chip.tabIndex = 0;

        // Add delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.className = 'chip-delete';
        deleteBtn.textContent = 'x';
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removeSearchTagChip(text);
        });

        chip.appendChild(deleteBtn);
        librarySearchChips.appendChild(chip);
        updateClearButtonState();
    }

    function removeSearchTagChip(tagText) {
        // Remove from searchTags array
        searchTags = searchTags.filter(tag => tag.text !== tagText);

        // Remove from DOM
        const chips = librarySearchChips.querySelectorAll('.search-chip');
        chips.forEach(chip => {
            if (chip.textContent.replace('x', '').trim() === tagText) {
                chip.remove();
            }
        });

        // Update search input and refresh results
        updateSearchInput();
        updateClearButtonState();
        displayLibraryImages();
    }

    function updateSearchInput() {
        librarySearchInput.value = searchTags.map(tag => tag.text).join(', ');
    }

    function clearAllSearchChips() {
        searchTags = [];
        librarySearchChips.innerHTML = '';
        librarySearchInput.value = '';
        updateClearButtonState();
        displayLibraryImages();
    }

    function updateClearButtonState() {
        clearAllTagsBtn.disabled = searchTags.length === 0;
    }

    function getMatchingTags(imageTags, searchTags) {
        if (!imageTags || !searchTags || searchTags.length === 0) {
            return [];
        }

        // Return tags that are both in the image and in the search
        return imageTags.filter(imageTag =>
            searchTags.some(searchTag =>
                searchTag.toLowerCase() === imageTag.toLowerCase()
            )
        );
    }

    function displayLightboxTags(index) {
        if (index >= libraryImages.length || index < 0) {
            lightboxTags.innerHTML = '';
            return;
        }

        const currentImage = libraryImages[index];
        const imageTags = currentImage.tags || [];

        lightboxTags.innerHTML = '';

        if (imageTags.length === 0) {
            lightboxTags.innerHTML = '<span class="no-tags">No tags</span>';
            return;
        }

        // Create tag chips for lightbox
        imageTags.forEach(tagText => {
            const chip = document.createElement('span');
            chip.className = 'lightbox-tag-chip';
            chip.textContent = tagText;

            // Highlight if it matches current search
            const currentSearchTags = searchTags.map(tag => tag.text);
            if (currentSearchTags.some(searchTag =>
                searchTag.toLowerCase() === tagText.toLowerCase())) {
                chip.classList.add('highlighted');
            }

            lightboxTags.appendChild(chip);
        });
    }

    // --- Event Listeners ---

    navLinks.library.addEventListener('click', (e) => { e.preventDefault(); navigateTo('library'); });
    navLinks.upload.addEventListener('click', (e) => { e.preventDefault(); navigateTo('upload'); });

    fileInput.addEventListener('change', (event) => {
        handleFiles(event.target.files);
    });

    clearAllButton.addEventListener('click', () => {
        previewGrid.innerHTML = '';
        filesToUpload = [];
        fileInput.value = '';
    });

    subjInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === 'Tab' || e.key === ',') {
            e.preventDefault();
            handleSubjCommit();
        } else if (e.key === 'Backspace' && subjInput.value === '') {
            const chips = subjChips.querySelectorAll('.chip');
            const last = chips[chips.length - 1];
            if (last) subjChips.removeChild(last);
        }
    });

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropzone.addEventListener(eventName, (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, false);
    });
    ['dragenter', 'dragover'].forEach(eventName => {
        dropzone.addEventListener(eventName, () => dropzone.classList.add('is-dragover'), false);
    });
    ['dragleave', 'drop'].forEach(eventName => {
        dropzone.addEventListener(eventName, () => dropzone.classList.remove('is-dragover'), false);
    });
    dropzone.addEventListener('drop', (e) => {
        handleFiles(e.dataTransfer.files);
    }, false);

    window.addEventListener('paste', (e) => {
        if (pages.upload.classList.contains('is-hidden')) return;
        handleFiles(e.clipboardData.files);
        dropzone.classList.add('is-dragover');
        setTimeout(() => dropzone.classList.remove('is-dragover'), 150);
    });

    prevButton.addEventListener('click', () => {
        if (libraryImages.length > 0) {
            showLibraryImage(currentImageIndex - 1);
        } else {
            showImage(currentImageIndex - 1);
        }
    });

    nextButton.addEventListener('click', () => {
        if (libraryImages.length > 0) {
            showLibraryImage(currentImageIndex + 1);
        } else {
            showImage(currentImageIndex + 1);
        }
    });

    closeModal.addEventListener('click', hideModal);

    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            hideModal();
        }
    });

    // Add keyboard support for Escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !modal.classList.contains('is-hidden')) {
            hideModal();
        }
    });

    const loadingOverlay = document.getElementById('loading-overlay');
    const confirmModal = document.getElementById('confirm-modal');
    const uploadMoreBtn = document.getElementById('upload-more-btn');
    const goToLibraryBtn = document.getElementById('go-to-library-btn');

    function clearUploadUI() {
        previewGrid.innerHTML = '';
        subjChips.innerHTML = '';
        filesToUpload = [];
        fileInput.value = '';
    }

    uploadMoreBtn.addEventListener('click', () => {
        confirmModal.classList.add('is-hidden');
        clearUploadUI();
        uploadButton.disabled = false; // Re-enable
    });

    goToLibraryBtn.addEventListener('click', () => {
        confirmModal.classList.add('is-hidden');
        clearUploadUI();
        uploadButton.disabled = false; // Re-enable
        navigateTo('library');
    });

    uploadButton.addEventListener('click', async () => {
        const tags = Array.from(subjChips.querySelectorAll('.chip')).map(chip => chip.textContent.replace(/x$/, '').trim());

        if (filesToUpload.length === 0) {
            return alert('Please select images to upload.');
        }

        const formData = new FormData();
        filesToUpload.forEach(file => {
            formData.append('images', file);
        });
        formData.append('tags', JSON.stringify(tags));

        uploadButton.disabled = true;
        loadingOverlay.classList.remove('is-hidden');

        try {
            const response = await fetch(`${API_URL}/upload`, {
                method: 'POST',
                body: formData
            });

            loadingOverlay.classList.add('is-hidden');

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Upload failed: ${errorText}`);
            }

            // On success, show the custom confirmation dialog
            confirmModal.classList.remove('is-hidden');

        } catch (error) {
            console.error('Error uploading images:', error);
            alert(`An error occurred during upload. Please try again. Details: ${error.message}`);
            loadingOverlay.classList.add('is-hidden');
            uploadButton.disabled = false;
        }
    });

    // Handle tag input with Enter, Tab, or comma
    librarySearchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === 'Tab' || e.key === ',') {
            e.preventDefault();
            handleSearchTagCommit();
        } else if (e.key === 'Backspace' && librarySearchInput.value === '') {
            // Remove last chip when backspacing on empty input
            if (searchTags.length > 0) {
                const lastTag = searchTags[searchTags.length - 1];
                removeSearchTagChip(lastTag.text);
            }
        }
    });

    // Also handle input changes for real-time search
    librarySearchInput.addEventListener('input', (e) => {
        // If user clears the input, clear all chips
        if (e.target.value === '') {
            clearAllSearchChips();
        }
    });

    function handleSearchTagCommit() {
        const inputValue = librarySearchInput.value.trim();
        if (!inputValue) return;

        // Split by comma and add each tag as a chip
        const newTags = inputValue.split(',').map(tag => tag.trim()).filter(tag => tag);
        newTags.forEach(tagText => {
            addSearchTagChip(tagText, true); // Default to has matches, will be updated
        });

        // Clear input and refresh search
        librarySearchInput.value = '';
        displayLibraryImages();
    }

    searchModeRadios.forEach(radio => radio.addEventListener('change', displayLibraryImages));

    // Clear all tags button
    clearAllTagsBtn.addEventListener('click', () => {
        clearAllSearchChips();
    });

    // Initialize button state
    updateClearButtonState();


  </script>
</body>
</html>

